<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asonik Store</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js";
        import { getAuth, signInWithPopup, GoogleAuthProvider, onAuthStateChanged, signOut, updateProfile } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-auth.js";
        import { getFirestore, collection, onSnapshot, addDoc, doc, deleteDoc, setDoc, serverTimestamp, query, where, orderBy, updateDoc, getDocs, increment, getDoc } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js";
        
        window.firebase = {
            initializeApp, getAuth, signInWithPopup, GoogleAuthProvider, onAuthStateChanged, signOut, updateProfile,
            getFirestore, collection, onSnapshot, addDoc, doc, deleteDoc, setDoc, serverTimestamp, query, where, orderBy, updateDoc, getDocs, increment, getDoc
        };
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; transition: background-color 0.3s, color 0.3s; }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        
        :root {
            --bg-primary: #111827;
            --bg-secondary: #1f2937;
            --bg-tertiary: #374151;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --accent-primary: #8b5cf6;
            --accent-secondary: #a78bfa;
            --border-color: #374151;
        }
        body.light {
            --bg-primary: #f9fafb;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f3f4f6;
            --text-primary: #111827;
            --text-secondary: #4b5563;
            --border-color: #e5e7eb;
        }
        body.asonik {
            --bg-primary: linear-gradient(to bottom right, #f3e8ff, #ffffff);
            --bg-secondary: #ffffff;
            --bg-tertiary: #f3f4f6;
            --text-primary: #4c1d95;
            --text-secondary: #6d28d9;
            --accent-primary: #8b5cf6;
            --accent-secondary: #a78bfa;
            --border-color: #e5e7eb;
        }
        .asonik .accent-text { color: var(--accent-primary); }
        .asonik .text-primary { color: var(--text-primary); }
        .asonik .text-secondary { color: var(--text-secondary); }
        .asonik .bg-secondary { box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.05), 0 2px 4px -2px rgb(0 0 0 / 0.05); }
        .asonik .border-color { border-color: var(--border-color); }
        .asonik .header-text { color: #4c1d95; }
        .asonik .header-text:hover { color: #6d28d9; }

        /* Mobile Menu styles */
        .mobile-menu-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-primary); /* Use var for consistency, or solid color if needed */
            z-index: 50;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            transform: translateX(100%);
            transition: transform 0.3s ease-out;
            overflow-y: auto; /* Add scroll for content that overflows */
        }
        .mobile-menu-container.open {
            transform: translateX(0%);
        }
        .mobile-menu-item {
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            border-radius: 0.5rem;
            transition: background-color 0.2s;
        }
        .mobile-menu-item:hover {
            background-color: var(--bg-secondary);
        }

        .bg-primary { background: var(--bg-primary); }
        .bg-secondary { background-color: var(--bg-secondary); }
        .bg-tertiary { background-color: var(--bg-tertiary); }
        .text-primary { color: var(--text-primary); }
        .text-secondary { color: var(--text-secondary); }
        .border-color { border-color: var(--border-color); }
        .accent-text { color: var(--accent-primary); }
        .accent-bg { background-color: var(--accent-primary); }
        .accent-border { border-color: var(--accent-primary); }
        .hover\:accent-bg:hover { background-color: var(--accent-primary); }
        .hover\:accent-bg-secondary:hover { background-color: var(--accent-secondary); }
    </style>
</head>
<body class="bg-primary text-primary">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef, useMemo, Component } = React;
        const { 
            initializeApp, getAuth, signInWithPopup, GoogleAuthProvider, onAuthStateChanged, signOut, updateProfile,
            getFirestore, collection, onSnapshot, addDoc, doc, deleteDoc, setDoc, serverTimestamp, query, where, orderBy, updateDoc, getDocs, increment, getDoc 
        } = window.firebase;

        // --- App Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyC7smDYoy-LT58xCwjJsc9uZU9CgHQv5dM",
            authDomain: "ya-buxgalter.firebaseapp.com",
            projectId: "ya-buxgalter",
            storageBucket: "ya-buxgalter.appspot.com",
            messagingSenderId: "640345805387",
            appId: "1:640345805387:web:a1adade77f809af84cb3ce",
            measurementId: "G-0TKE25JVXG"
        };
        
        const ADMIN_UID = 'vhmtXZxkZnOWviNQ39R1W3GE8mw2'; // Ensure this matches your Firebase Admin UID
        const ADMIN_PIN = '300414';
        const IMGBB_API_KEY = '96bf3f29606f1989bb5a450ad3770cce';

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const provider = new GoogleAuthProvider();
        
        const logoBase64 = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAgACADASIAAhEBAx toutinAD2ERkACK5uX1WzYtprKqKxckO2E5sNqS0lxLbqFpWlQBSoAgjYI9j39cZkABEV7OpaO6xYlXl0V6bYSHENNR2klS1qUoJSkAekkkgD+8YkABGczL6bT1kuyupLMNhhJWtbywkgD6Gz1J+g98ZkAB//2Q==";

        // --- Helper Components & Functions ---
        const generatePurchaseCode = () => {
            const chars = 'ABCDEFGHIJKLMNPQRSTUVWXYZ13456789';
            let result = '';
            for (let i = 0; i < 6; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result.match(/.{1,3}/g).join('-');
        };

        const generateShortId = (longId) => {
            if (!longId || longId.length < 8) return longId; // Return as is if too short
            return `${longId.substring(0, 4)}-${longId.substring(longId.length - 4)}`;
        };
        
        const Logo = () => ( <div className="flex items-center space-x-2 cursor-pointer"> <img src={logoBase64} alt="Asonik Store Logo" className="h-12 w-12 object-contain"/> <span className="text-2xl md:text-3xl font-bold header-text tracking-wider"> Asonik <span className="accent-text">Store</span> </span> </div> );
        const LoadingSpinner = () => ( <div className="bg-primary min-h-screen flex items-center justify-center"><div className="animate-spin rounded-full h-32 w-32 border-t-4 border-b-4 accent-border"></div></div> );
        const Modal = ({ children, onClose, size = 'max-w-md' }) => ( <div className="fixed inset-0 bg-black bg-opacity-75 z-50 flex justify-center items-center p-4 transition-opacity duration-300"> <div className={`bg-secondary rounded-2xl shadow-2xl p-6 md:p-8 w-full ${size} relative border-color transform transition-transform duration-300 scale-95 animate-scale-in`}> <button onClick={onClose} className="absolute top-4 right-4 text-secondary hover:text-primary transition-colors z-10"> <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg> </button> {children} </div> <style>{` @keyframes scale-in { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } } .animate-scale-in { animation: scale-in 0.3s ease-out forwards; } `}</style> </div> );
        const AlertModal = ({ message, onConfirm, onCancel, t }) => ( <Modal onClose={onCancel}> <div className="text-center"> <h2 className="text-2xl font-bold text-primary mb-4">{t.confirmation}</h2> <p className="text-secondary mb-6 whitespace-pre-wrap">{message}</p> <div className={`flex ${onConfirm ? 'justify-between' : 'justify-center'} space-x-4`}> <button onClick={onCancel} className="bg-tertiary hover:bg-gray-700 text-primary font-bold py-2 px-6 rounded-lg transition-colors">{onConfirm ? t.cancel : t.ok}</button> {onConfirm && ( <button onClick={onConfirm} className="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg transition-colors">{t.confirm}</button> )} </div> </div> </Modal> );
        
        const ProfileModal = ({ user, onClose, t, setAlertInfo, onLogout }) => { // Added onLogout prop
            const [isUploading, setIsUploading] = useState(false);
            const [borderColor, setBorderColor] = useState('#8b5cf6'); // Renamed color to borderColor
            const fileInputRef = useRef(null);
            const [firstName, setFirstName] = useState('');
            const [lastName, setLastName] = useState('');
            const [nickname, setNickname] = useState(''); // New state for nickname

            useEffect(() => {
                if (user.displayName) {
                    const parts = user.displayName.split(' ');
                    setFirstName(parts[0] || '');
                    setLastName(parts.slice(1).join(' ') || '');
                }
                // Fetch existing custom border color if stored
                const fetchUserData = async () => {
                    const userDoc = await getDoc(doc(db, "users", user.uid));
                    if (userDoc.exists()) {
                        const userData = userDoc.data();
                        if (userData.borderColor) {
                            setBorderColor(userData.borderColor);
                        }
                    }
                };
                if (user) fetchUserData();

            }, [user]); // Depend on user object, so changes trigger this

            const handleUpdateProfile = async (e) => {
                e.preventDefault();
                setIsUploading(true);
                try {
                    const newDisplayName = `${firstName} ${lastName}`.trim();
                    await updateProfile(auth.currentUser, { displayName: newDisplayName });
                    
                    // Update user's custom data (including nickname and border color) in Firestore
                    await setDoc(doc(db, "users", user.uid), { 
                        nickname: nickname,
                        borderColor: borderColor, // Save border color
                    }, { merge: true });

                    setAlertInfo({ message: t.profileUpdated || 'Профиль обновлен!' });
                    onAuthStateChanged(auth, (currentUser) => { /* force re-render with updated info */ });
                }  catch (error) {
                    console.error("Error updating profile:", error);
                    setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                } finally {
                    setIsUploading(false);
                    onClose();
                }
            };


            const handleImageUpload = async (file) => {
                if (!file) return;
                if (!IMGBB_API_KEY) { setAlertInfo({ message: t.noApiKey }); return; }
                setIsUploading(true);
                const formData = new FormData();
                formData.append('image', file);

                try {
                    const response = await fetch(`https://api.imgbb.com/1/upload?key=${IMGBB_API_KEY}`, { method: 'POST', body: formData });
                    const result = await response.json();
                    if (result.success) {
                        await updateProfile(auth.currentUser, { photoURL: result.data.url });
                        // Save photoURL in user document for consistency if needed later
                        await setDoc(doc(db, "users", user.uid), { photoURL: result.data.url }, { merge: true });
                        setAlertInfo({ message: t.avatarUpdated });
                    } else { throw new Error(result.error.message); }
                } catch (error) { console.error("Error uploading avatar:", error); setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` }); } 
                finally { setIsUploading(false); onClose(); }
            };
            
            // This function is no longer needed as color picker only changes border, not avatar itself
            // const handleColorAvatar = async () => {
            //     const colorHex = color.substring(1);
            //     const photoURL = `https://placehold.co/128x128/${colorHex}/FFFFFF?text=${user.displayName ? user.displayName.charAt(0) : '?'}`;
            //     try {
            //         await updateProfile(auth.currentUser, { photoURL });
            //         setAlertInfo({ message: t.avatarUpdated });
            //     } catch(error) { console.error("Error setting color avatar:", error); setAlertInfo({ message: t.errorOccurred }); }
            //     finally { onClose(); }
            // };

            const handleRevertAvatar = async () => {
                const originalPhotoURL = auth.currentUser.providerData[0]?.photoURL;
                if (originalPhotoURL) {
                    try {
                        await updateProfile(auth.currentUser, { photoURL: originalPhotoURL });
                        // Update user document as well
                        await setDoc(doc(db, "users", user.uid), { photoURL: originalPhotoURL }, { merge: true });
                        setAlertInfo({ message: t.avatarReverted });
                    } catch (error) { console.error("Error reverting avatar:", error); setAlertInfo({ message: t.errorOccurred }); } 
                    finally { onClose(); }
                }
            };

            return (
                <Modal onClose={onClose}>
                    <div className="text-center text-primary">
                        <h2 className="text-3xl font-bold mb-4">{t.profile}</h2>
                        <div className="relative mx-auto mb-4 w-24 h-24">
                             <img src={user.photoURL} alt={user.displayName} className={`w-full h-full rounded-full mx-auto border-4 object-cover`} style={{ borderColor: borderColor }}/> {/* Dynamic border color */}
                             <button onClick={() => fileInputRef.current.click()} className="absolute bottom-0 right-0 bg-gray-700 p-2 rounded-full border border-color">
                                 <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M13.586 3.586a2 2 0 112.828 2.828l-7.293 7.293A1 1 0 018.657 14H5a1 1 0 01-1-1v-3.657a1 1 0 01.293-.707l7.293-7.293zM10 2a1 1 0 00-1 1v2a1 1 0 102 0V3a1 1 0 00-1-1z" /></svg>
                             </button>
                        </div>
                        <p className="text-xl mb-2">{user.displayName}</p>
                        <p className="text-secondary mb-6">{user.email}</p>
                        
                        <form onSubmit={handleUpdateProfile} className="space-y-4 mb-6">
                            <div>
                                <label className="block text-secondary text-sm font-bold mb-1">{t.firstName || 'Имя'}</label>
                                <input type="text" value={firstName} onChange={e => setFirstName(e.target.value)} className="w-full p-2 bg-tertiary rounded-lg border-color text-primary"/>
                            </div>
                            <div>
                                <label className="block text-secondary text-sm font-bold mb-1">{t.lastName || 'Фамилия'}</label>
                                <input type="text" value={lastName} onChange={e => setLastName(e.target.value)} className="w-full p-2 bg-tertiary rounded-lg border-color text-primary"/>
                            </div>
                            <div>
                                <label className="block text-secondary text-sm font-bold mb-1">{t.nickname || 'Никнейм'}</label>
                                <input type="text" value={nickname} onChange={e => setNickname(e.target.value)} className="w-full p-2 bg-tertiary rounded-lg border-color text-primary"/>
                            </div>
                            <button type="submit" className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors" disabled={isUploading}>
                                {isUploading ? t.sending : t.updateProfile || 'Обновить профиль'}
                            </button>
                        </form>


                        <div className="space-y-3">
                            <div className="flex items-center space-x-2">
                                <button type="button" className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">{t.setColorBorder || 'Установить цвет рамки'}</button> {/* Changed label */}
                                <input type="color" value={borderColor} onChange={e => setBorderColor(e.target.value)} className="p-1 h-10 w-14 block bg-tertiary border-color cursor-pointer rounded-lg"/>
                            </div>
                            <button onClick={handleRevertAvatar} className="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">{t.revertAvatar}</button>
                            <button onClick={onLogout} className="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-colors mt-4">{t.logout}</button>
                        </div>
                        <input type="file" ref={fileInputRef} onChange={(e) => handleImageUpload(e.target.files[0])} accept="image/*" className="hidden"/>
                    </div>
                </Modal>
            );
        };
        
        const CustomSelector = ({ value, onChange, options }) => {
            const [isOpen, setIsOpen] = useState(false);
            const wrapperRef = useRef(null);

            useEffect(() => {
                function handleClickOutside(event) {
                    if (wrapperRef.current && !wrapperRef.current.contains(event.target)) { setIsOpen(false); }
                }
                document.addEventListener("mousedown", handleClickOutside);
                return () => document.removeEventListener("mousedown", handleClickOutside);
            }, [wrapperRef]);

            const handleSelect = (newValue) => {
                onChange({ target: { value: newValue } });
                setIsOpen(false);
            };

            return (
                <div className="relative" ref={wrapperRef}>
                    <button onClick={() => setIsOpen(!isOpen)} className="flex items-center justify-between w-full bg-tertiary hover:bg-gray-700 text-primary font-semibold py-2 px-4 rounded-lg transition-colors">
                        <span>{options.find(o => o.value === value).label}</span>
                        <svg className={`w-4 h-4 transition-transform ${isOpen ? 'transform rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    {isOpen && (
                        <div className="absolute right-0 mt-2 w-full bg-tertiary rounded-md shadow-lg py-1 z-50 border-color">
                            {options.map(opt => (
                                <a href="#" key={opt.value} onClick={(e) => { e.preventDefault(); handleSelect(opt.value); }}
                                    className={`block px-4 py-2 text-sm text-secondary hover:text-primary hover:accent-bg ${value === opt.value ? 'accent-bg text-white' : ''}`}>
                                    {opt.label}
                                </a>
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        const PinModal = ({ onSubmit, onClose, error, t, setRememberMe }) => {
            const [pin, setPin] = useState('');
            const [attempts, setAttempts] = useState(0);
            const [isLocked, setIsLocked] = useState(false);
            const [countdown, setCountdown] = useState(0);
            const [rememberMeChecked, setRememberMeChecked] = useState(false); // New state for checkbox

            useEffect(() => {
                let timer;
                if (isLocked) {
                    setCountdown(15);
                    timer = setInterval(() => {
                        setCountdown(prev => {
                            if (prev <= 1) {
                                clearInterval(timer);
                                setIsLocked(false);
                                setAttempts(0);
                                return 0;
                            }
                            return prev - 1;
                        });
                    }, 1000);
                }
                return () => clearInterval(timer);
            }, [isLocked]);

            const handleSubmit = (e) => {
                e.preventDefault();
                if (isLocked) return;

                const success = onSubmit(pin, rememberMeChecked); // Pass rememberMeChecked
                if (!success) {
                    const newAttempts = attempts + 1;
                    setAttempts(newAttempts);
                    if (newAttempts >= 5) {
                        setIsLocked(true);
                    }
                }
            };

            return (
                <Modal onClose={onClose} size="max-w-sm">
                    <form onSubmit={handleSubmit} className="text-center">
                        <h2 className="text-2xl font-bold text-primary mb-4">{t.adminAccess}</h2>
                        <p className="text-secondary mb-6">{t.enterPin}</p>
                        <input
                            type="password"
                            value={pin}
                            onChange={(e) => setPin(e.target.value)}
                            className="w-full p-3 bg-tertiary rounded-lg border-color text-primary text-center text-2xl tracking-[.5em] disabled:opacity-50"
                            maxLength="6"
                            autoFocus
                            disabled={isLocked}
                        />
                        {error && !isLocked && <p className="text-red-500 text-sm mt-2">{error}</p>}
                        {isLocked && <p className="text-yellow-500 text-sm mt-2">Слишком много попыток. Попробуйте через {countdown} секунд.</p>}
                        
                        {/* Remember Me checkbox */}
                        <div className="flex items-center justify-center mt-4">
                            <input
                                type="checkbox"
                                id="rememberMe"
                                checked={rememberMeChecked}
                                onChange={(e) => setRememberMeChecked(e.target.checked)}
                                className="form-checkbox h-4 w-4 text-purple-600 rounded"
                            />
                            <label htmlFor="rememberMe" className="ml-2 text-sm text-secondary">{t.rememberMe || 'Запомнить меня (15 минут)'}</label> {/* Changed to 15 minutes */}
                        </div>

                        <button type="submit" className="w-full mt-6 accent-bg hover:accent-bg-secondary text-white font-bold py-3 px-4 rounded-lg transition-colors disabled:bg-gray-500" disabled={isLocked}>
                            {isLocked ? `Заблокировано (${countdown})` : t.enter}
                        </button>
                    </form>
                </Modal>
            );
        };

        // --- Main Components ---
        function Header({ user, onLogin, onLogout, setPage, isAdmin, t, currency, setCurrency, language, setLanguage, setProfileVisible, theme, setTheme, onAdminClick }) {
            const [userDropdownOpen, setUserDropdownOpen] = useState(false);
            const [mobileMenuOpen, setMobileMenuOpen] = useState(false); // New state for mobile menu
            const userDropdownRef = useRef(null);

            const langOptions = [{value: 'ru', label: t.russian}, {value: 'en', label: t.english}, {value: 'uz', label: t.uzbek}];
            const currencyOptions = [{value: 'RUB', label: t.ruble}, {value: 'USD', label: t.dollar}, {value: 'UZS', label: t.sum}];
            const themeOptions = [{value: 'dark', label: t.darkTheme}, {value: 'light', label: t.lightTheme}, {value: 'asonik', label: t.asonikTheme}];

            useEffect(() => {
                function handleClickOutside(event) {
                    if (userDropdownRef.current && !userDropdownRef.current.contains(event.target)) { setUserDropdownOpen(false); }
                }
                document.addEventListener("mousedown", handleClickOutside);
                return () => document.removeEventListener("mousedown", handleClickOutside);
            }, [userDropdownRef]);
            
            const handleMenuItemClick = (pageName) => {
                setPage(pageName);
                setMobileMenuOpen(false); // Close mobile menu on item click
            };

            return (
                <header className="bg-secondary p-4 shadow-lg sticky top-0 z-40 border-b border-color">
                    <div className="container mx-auto flex justify-between items-center">
                        <div onClick={() => handleMenuItemClick('home')}><Logo /></div> {/* Changed to handleMenuItemClick for consistency */}
                        <nav className="hidden md:flex items-center space-x-6">
                            <button onClick={() => handleMenuItemClick('home')} className="text-secondary hover:text-primary font-medium transition-colors">{t.home}</button>
                            {user && <button onClick={() => handleMenuItemClick('purchases')} className="text-secondary hover:text-primary font-medium transition-colors">{t.myPurchases}</button>}
                            <button onClick={() => handleMenuItemClick('faq')} className="text-secondary hover:text-primary font-medium transition-colors">{t.faq}</button>
                            {user && <button onClick={() => handleMenuItemClick('chats')} className="text-secondary hover:text-primary font-medium transition-colors">{t.chats}</button>} {/* New Chats button */}
                        </nav>
                        <div className="flex items-center space-x-2 sm:space-x-4">
                            <div className="hidden md:block w-28"><CustomSelector value={language} onChange={e => setLanguage(e.target.value)} options={langOptions} /></div>
                            <div className="hidden md:block w-28"><CustomSelector value={currency} onChange={e => setCurrency(e.target.value)} options={currencyOptions} /></div>
                            <div className="hidden md:block w-32"><CustomSelector value={theme} onChange={e => setTheme(e.target.value)} options={themeOptions} /></div>
                            
                            {user ? (
                                <div className="relative" ref={userDropdownRef}>
                                    <button onClick={() => setUserDropdownOpen(!userDropdownOpen)} className="flex items-center space-x-2">
                                        <img src={user.photoURL} alt={user.displayName} className="h-10 w-10 rounded-full border-2 accent-border object-cover" />
                                        <svg className={`w-4 h-4 text-primary transition-transform ${userDropdownOpen ? 'transform rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7"></path></svg>
                                    </button>
                                    {userDropdownOpen && (
                                        <div className={`absolute right-0 mt-2 w-48 bg-secondary rounded-md shadow-lg py-1 z-50 border-color`}>
                                            <a href="#" onClick={(e) => { e.preventDefault(); setProfileVisible(true); setUserDropdownOpen(false); }} className="block px-4 py-2 text-sm text-secondary hover:text-primary hover:accent-bg">{t.profile}</a>
                                            {isAdmin && <a href="#" onClick={(e) => { e.preventDefault(); onAdminClick(); setUserDropdownOpen(false); }} className="block px-4 py-2 text-sm text-red-500 hover:text-red-400 hover:accent-bg">{t.adminPanelTitle}</a>}
                                            <a href="#" onClick={(e) => { e.preventDefault(); onLogout(); setUserDropdownOpen(false); }} className="block px-4 py-2 text-sm text-secondary hover:text-primary hover:accent-bg">{t.logout}</a>
                                        </div>
                                    )}
                                </div>
                            ) : (
                                <button onClick={onLogin} className="accent-bg hover:accent-bg-secondary text-white font-bold py-2 px-4 rounded-lg transition-transform transform hover:scale-105 flex items-center space-x-2">
                                    <span>{t.login}</span>
                                </button>
                            )}
                            <button className="md:hidden p-2 rounded-md text-primary hover:bg-tertiary" onClick={() => setMobileMenuOpen(!mobileMenuOpen)}>
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" /></svg>
                            </button>
                        </div>
                    </div>

                    {/* Mobile Menu */}
                    <div className={`mobile-menu-container ${mobileMenuOpen ? 'open' : ''}`}>
                        <div className="flex justify-end mb-4">
                            <button className="p-2 rounded-md text-primary hover:bg-secondary" onClick={() => setMobileMenuOpen(false)}>
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>
                            </button>
                        </div>
                        <button onClick={() => handleMenuItemClick('home')} className="mobile-menu-item">{t.home}</button>
                        {user && <button onClick={() => handleMenuItemClick('purchases')} className="mobile-menu-item">{t.myPurchases}</button>}
                        <button onClick={() => handleMenuItemClick('faq')} className="mobile-menu-item">{t.faq}</button>
                        {user && <button onClick={() => handleMenuItemClick('chats')} className="mobile-menu-item">{t.chats}</button>}
                        {user ? (
                            <>
                                <button onClick={() => { setProfileVisible(true); setMobileMenuOpen(false); }} className="mobile-menu-item">{t.profile}</button>
                                {isAdmin && <button onClick={() => { onAdminClick(); setMobileMenuOpen(false); }} className="mobile-menu-item text-red-500">{t.adminPanelTitle}</button>}
                                <button onClick={() => { onLogout(); setMobileMenuOpen(false); }} className="mobile-menu-item">{t.logout}</button>
                            </>
                        ) : (
                            <button onClick={() => { onLogin(); setMobileMenuOpen(false); }} className="mobile-menu-item">{t.login}</button>
                        )}
                         <div className="mt-auto pt-4 border-t border-color flex flex-col items-center">
                            <div className="w-full mb-2"><CustomSelector value={language} onChange={e => setLanguage(e.target.value)} options={langOptions} /></div>
                            <div className="w-full mb-2"><CustomSelector value={currency} onChange={e => setCurrency(e.target.value)} options={currencyOptions} /></div>
                            <div className="w-full"><CustomSelector value={theme} onChange={e => setTheme(e.target.value)} options={themeOptions} /></div>
                        </div>
                    </div>
                </header>
            );
        }
        
        const SkeletonCard = () => (
            <div className="bg-secondary rounded-2xl overflow-hidden shadow-lg border-color animate-pulse">
                <div className="w-full h-56 bg-tertiary"></div>
                <div className="p-6">
                    <div className="h-8 bg-tertiary rounded w-3/4 mb-2"></div>
                    <div className="h-6 bg-tertiary rounded w-1/2 mb-4"></div>
                    <div className="h-10 bg-tertiary rounded w-1/3"></div>
                </div>
            </div>
        );

        function HomePage({ products, onProductClick, t, currency, convertPrice, loading }) {
            const [searchTerm, setSearchTerm] = useState('');
            const [filterCategory, setFilterCategory] = useState('all');
            const [sortBy, setSortBy] = useState('new');

            const filteredAndSortedProducts = useMemo(() => {
                return products
                    .filter(p => p.isOnSale === undefined || p.isOnSale !== false) // Filter out products removed from sale, or include if isOnSale is undefined
                    .filter(p => p.name.toLowerCase().includes(searchTerm.toLowerCase()))
                    .filter(p => filterCategory === 'all' || p.category === filterCategory)
                    .sort((a, b) => {
                        if (a.pinned && !b.pinned) return -1;
                        if (!a.pinned && b.pinned) return 1;
                        if (sortBy === 'popular') return (b.popularity || 0) - (a.popularity || 0);
                        return (b.createdAt?.toMillis() || 0) - (a.createdAt?.toMillis() || 0);
                    });
            }, [products, searchTerm, filterCategory, sortBy]);

            const FilterButton = ({ value, state, setState, children }) => (
                <button onClick={() => setState(value)} className={`px-4 py-2 rounded-lg text-sm transition-colors ${state === value ? 'accent-bg text-white' : 'bg-tertiary text-primary hover:bg-gray-600'}`}>
                    {children}
                </button>
            );

            const categories = useMemo(() => {
                const cats = { all: t.all };
                products.forEach(p => { if (p.category) cats[p.category] = p.category; });
                return Object.keys(cats).map(key => ({ value: key, label: t[key.toLowerCase()] || key }));
            }, [products, t]);

            return (
                <main className="container mx-auto p-4 md:p-8">
                    <h1 className="text-4xl md:text-5xl font-black text-primary text-center mb-4 tracking-wide">{t.catalogTitle}</h1>
                    <p className="accent-text text-center mb-8 text-lg">{t.catalogSubtitle}</p>
                    
                    <div className="bg-secondary p-4 rounded-xl mb-8 flex flex-col md:flex-row gap-4 items-center">
                        <input type="text" placeholder={t.searchPlaceholder} value={searchTerm} onChange={e => setSearchTerm(e.target.value)} className="w-full md:w-1/3 p-3 bg-tertiary rounded-lg border-color focus:outline-none focus:ring-2 accent-border text-primary" />
                        <div className="flex items-center gap-2">
                            <span className="text-secondary font-semibold">{t.category}:</span>
                            <div className="w-40"><CustomSelector value={filterCategory} onChange={e => setFilterCategory(e.target.value)} options={categories} /></div>
                        </div>
                        <div className="flex items-center gap-2 ml-auto">
                            <span className="text-secondary font-semibold">{t.sortBy}:</span>
                            <FilterButton value="new" state={sortBy} setState={setSortBy}>{t.newSort}</FilterButton>
                            <FilterButton value="popular" state={sortBy} setState={setSortBy}>{t.popularSort}</FilterButton>
                        </div>
                    </div>
                    
                    {loading ? (
                         <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
                            {[...Array(6)].map((_, i) => <SkeletonCard key={i} />)}
                        </div>
                    ) : filteredAndSortedProducts.length === 0 ? (
                         <p className="text-center text-secondary text-xl mt-12">{t.productsNotFound}</p>
                    ) : (
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
                            {filteredAndSortedProducts.map(product => (
                                <ProductCard key={product.id} {...{product, onProductClick, t, currency, convertPrice}} />
                            ))}
                        </div>
                    )}
                </main>
            );
        }

        function ProductCard({ product, onProductClick, t, currency, convertPrice }) {
            const imageUrl = (product.imageUrls && product.imageUrls.length > 0) ? product.imageUrls[0] : (product.imageUrl || '');
            const displayPrice = useMemo(() => {
                if (product.variants && product.variants.length > 0) {
                    const minPrice = Math.min(...product.variants.map(v => v.price));
                    return convertPrice(minPrice, currency);
                }
                return convertPrice(product.price || 0, currency); // Fallback for old structure or if price is undefined
            }, [product.variants, product.price, currency]);
            
            const displayNominal = useMemo(() => {
                if (product.variants && product.variants.length > 0) {
                    return product.variants[0].nominal;
                }
                return product.nominal; // Fallback for old structure
            }, [product.variants, product.nominal]);

            const displayStock = useMemo(() => {
                if (product.variants && product.variants.length > 0) {
                    // Sum stock quantities from all variants for overall card display
                    const totalStock = product.variants.reduce((sum, v) => sum + (parseInt(v.stockQuantity) || 0), 0);
                    return totalStock;
                }
                return (product.stockQuantity !== undefined ? product.stockQuantity : -1); // -1 means stock not tracked or old product
            }, [product.variants, product.stockQuantity]);


            return (
                <div onClick={() => onProductClick(product)} className="bg-secondary rounded-2xl overflow-hidden shadow-lg border-color transform hover:-translate-y-2 transition-transform duration-300 flex flex-col cursor-pointer relative">
                    {product.pinned && <div className="absolute top-0 right-0 bg-yellow-400 text-black text-xs font-bold px-3 py-1 rounded-bl-lg z-10">{t.pinned}</div>}
                    {product.isOnSale === false && <span className="absolute top-2 left-2 bg-gray-500 text-white text-xs font-bold px-2 py-1 rounded-full">{t.removedFromSale || 'Снято с продажи'}</span>}
                    <img className="w-full h-56 object-cover" src={imageUrl} alt={product.name} onError={(e) => { e.target.onerror = null; e.target.src=`https://placehold.co/600x400/1f2937/374151?text=${encodeURIComponent(t.imageNotFound)}`; }}/>
                    <div className="p-6 flex flex-col flex-grow">
                        {product.isVerified && (
                            <div className="flex items-center text-green-400 text-sm mb-2">
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" /></svg>
                                {t.verifiedByStore}
                            </div>
                        )}
                        <h3 className="text-2xl font-bold text-primary mb-1">{product.name}</h3>
                        {displayNominal && <p className="accent-text font-semibold mb-2">{displayNominal}</p>}
                        
                        {product.variants && product.variants.length > 1 && (
                            <p className="text-secondary text-sm mb-2">
                                {t.priceFrom}: {displayPrice} {product.variants.length > 1 && `+ ${product.variants.length - 1} ${t.moreOptions || 'варианта'}`}
                            </p>
                        )}
                        
                        <div className="flex-grow"></div>
                        <div className="flex justify-between items-center mt-4">
                            <span className="text-3xl font-bold accent-text">{displayPrice}</span>
                            {displayStock !== -1 && displayStock <= 0 && ( // General stock for card
                                <span className="bg-red-500 text-white text-xs font-bold px-2 py-1 rounded-full">{t.outOfStock || 'Нет в наличии'}</span>
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        function ProductModal({ product, user, onClose, onBuy, setAlertInfo, t, currency, convertPrice }) {
            const [currentImageIndex, setCurrentImageIndex] = useState(0);
            const imageUrls = (product.imageUrls && product.imageUrls.length > 0) ? product.imageUrls : [product.imageUrl || ''];
            const [selectedVariantIndex, setSelectedVariantIndex] = useState(0);

            useEffect(() => {
                // Reset selected variant when product changes or modal opens
                setSelectedVariantIndex(0);
            }, [product]);

            const currentVariant = product.variants && product.variants.length > 0
                ? product.variants[selectedVariantIndex]
                : { nominal: product.nominal, price: product.price, stockQuantity: product.stockQuantity }; // Fallback for old structure

            const nextImage = () => {
                setCurrentImageIndex((prevIndex) => (prevIndex + 1) % imageUrls.length);
            };

            const prevImage = () => {
                setCurrentImageIndex((prevIndex) => (prevIndex - 1 + imageUrls.length) % imageUrls.length);
            };

             const handleShare = () => {
                const productUrl = `${window.location.origin}${window.location.pathname}?product=${product.id}`;
                navigator.clipboard.writeText(productUrl).then(() => {
                    setAlertInfo({ message: t.linkCopied });
                }, () => {
                    const dummy = document.createElement('textarea');
                    document.body.appendChild(dummy);
                    dummy.value = productUrl;
                    dummy.select();
                    document.execCommand('copy');
                    document.body.removeChild(dummy);
                    setAlertInfo({ message: t.linkCopied });
                });
            };

            const handleBuyClick = () => {
                if (user) {
                    // Check stock for the selected variant
                    if (currentVariant.stockQuantity !== undefined && currentVariant.stockQuantity <= 0) {
                        setAlertInfo({ message: t.outOfStockMessage || 'Этот товар временно отсутствует на складе.' });
                        return;
                    }
                    // Pass product data + selected variant info
                    // The onBuy function in App will now receive product.selectedVariant and product.selectedVariantIndex
                    onBuy({ ...product, selectedVariant: currentVariant, selectedVariantIndex: selectedVariantIndex });
                } else {
                    setAlertInfo({ message: t.loginToBuy });
                }
            };

            return (
                <Modal onClose={onClose} size="max-w-4xl">
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                        <div className="relative">
                            <img src={imageUrls[currentImageIndex]} alt={product.name} className="w-full h-auto object-cover rounded-lg"/>
                            {imageUrls.length > 1 && (
                                <>
                                    <button onClick={prevImage} className="absolute left-2 top-1/2 -translate-y-1/2 bg-black bg-opacity-50 text-white p-2 rounded-full">‹</button>
                                    <button onClick={nextImage} className="absolute right-2 top-1/2 -translate-y-1/2 bg-black bg-opacity-50 text-white p-2 rounded-full">›</button>
                                </>
                            )}
                        </div>
                        <div className="flex flex-col">
                            {product.isVerified && (
                                <div className="flex items-center text-green-400 text-sm mb-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" /></svg>
                                    {t.verifiedByStore}
                                </div>
                            )}
                            <h2 className="text-4xl font-bold text-primary mb-2">{product.name}</h2>
                            
                            {/* Variants Selection */}
                            {product.variants && product.variants.length > 0 && (
                                <div className="my-4 space-y-2">
                                    <p className="text-lg font-semibold text-primary">{t.chooseOption || 'Выберите вариант:'}</p>
                                    <div className="flex flex-wrap gap-2">
                                        {product.variants.map((variant, index) => (
                                            <button
                                                key={index}
                                                onClick={() => setSelectedVariantIndex(index)}
                                                className={`px-4 py-2 rounded-lg text-sm font-semibold transition-colors ${selectedVariantIndex === index ? 'accent-bg text-white' : 'bg-tertiary text-primary hover:bg-gray-600'}`}
                                            >
                                                {variant.nominal} - {convertPrice(variant.price, currency)}
                                            </button>
                                        ))}
                                    </div>
                                    {currentVariant.stockQuantity !== undefined && currentVariant.stockQuantity <= 0 && (
                                        <p className="text-red-500 text-sm">{t.outOfStockMessage}</p>
                                    )}
                                </div>
                            )}
                            
                            {/* Display current selected nominal/price from variant or old fields */}
                            {(currentVariant.nominal || product.nominal) && <p className="text-xl accent-text font-semibold mb-4">{currentVariant.nominal || product.nominal}</p>}
                            <p className="text-secondary mb-6 flex-grow">{product.description}</p>
                            <div className="flex justify-between items-center">
                                <span className="text-5xl font-bold accent-text">{convertPrice(currentVariant.price || product.price, currency)}</span>
                                <div className="flex space-x-2">
                                    <button onClick={handleShare} className="bg-tertiary hover:bg-gray-700 p-4 rounded-lg transition-colors">
                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-primary" viewBox="0 0 20 20" fill="currentColor"><path d="M15 8a3 3 0 10-2.977-2.63l-4.94 2.47a3 3 0 100 4.319l4.94 2.47a3 3 0 10.895-1.789l-4.94-2.47a3.027 3.027 0 000-.74l4.94-2.47C13.456 7.68 14.19 8 15 8z" /></svg>
                                    </button>
                                    <button onClick={handleBuyClick} className="accent-bg hover:accent-bg-secondary text-white font-bold py-4 px-8 rounded-lg text-lg" disabled={currentVariant.stockQuantity !== undefined && currentVariant.stockQuantity <= 0}>
                                        {currentVariant.stockQuantity !== undefined && currentVariant.stockQuantity <= 0 ? t.outOfStock : t.buy}
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </Modal>
            );
        }

        function PurchaseModal({ product, onClose, onConfirm, onYooMoney, t, currency, convertPrice, setAlertInfo }) {
            const [promoCode, setPromoCode] = useState('');
            const [appliedPromo, setAppliedPromo] = useState(null);
            const [error, setError] = useState('');

            const finalPrice = useMemo(() => {
                const basePrice = product.selectedVariant ? product.selectedVariant.price : product.price; // Use selected variant price
                if (!appliedPromo) return basePrice;
                return basePrice * (1 - appliedPromo.discount / 100);
            }, [product.selectedVariant, product.price, appliedPromo]);

            const handleApplyPromo = async () => {
                setError('');
                if (!promoCode.trim()) return;
                
                const promoRef = doc(db, 'promoCodes', promoCode);
                const promoSnap = await getDoc(promoRef);

                if (promoSnap.exists()) {
                    const promoData = promoSnap.data();
                    if (promoData.timesUsed >= promoData.usageLimit) {
                        setError(t.promoLimitReached);
                        setAppliedPromo(null);
                    } else {
                        setAppliedPromo(promoData);
                        setAlertInfo({ message: t.promoApplied });
                    }
                } else {
                    setAppliedPromo(null);
                    setError(t.promoNotFound);
                }
            };

            const handleContactSeller = async () => {
                const purchaseDetails = {
                    finalPrice,
                    promoCodeUsed: appliedPromo ? appliedPromo.code : null,
                    paymentMethod: 'Chat', // Changed to Chat
                    nominal: product.selectedVariant ? product.selectedVariant.nominal : product.nominal, // Pass selected nominal
                };
                
                // Pre-fill chat message based on product details
                const initialChatMessage = `${t.autoChatMessagePrefix || 'Я хочу купить товар:'} ${product.name} (${purchaseDetails.nominal}) ${t.forPrice || 'за'} ${convertPrice(purchaseDetails.finalPrice, currency)}.`;
                
                // Now, call onConfirm from App, which will handle purchase record creation and stock decrement
                await onConfirm(product, purchaseDetails, initialChatMessage); 
                // setAlertInfo({ message: t.thankYouForRequest || 'Спасибо за запрос! Он будет обработан в течение 24 часов.' }); // Alert moved to App.handleConfirmPurchase
                
                onClose();
            };

            const handleYooMoneyClick = () => {
                const purchaseDetails = {
                    finalPrice,
                    promoCodeUsed: appliedPromo ? appliedPromo.code : null,
                    paymentMethod: 'YooMoney',
                    nominal: product.selectedVariant ? product.selectedVariant.nominal : product.nominal, // Pass selected nominal
                };
                onYooMoney(product, purchaseDetails);
                onClose();
            };

            return (
                <Modal onClose={onClose}>
                    <div className="text-center">
                        <h2 className="text-3xl font-bold text-primary mb-2">{t.checkout}</h2>
                        <p className="text-secondary mb-4">
                            {t.youAreBuying}: <span className="font-bold accent-text">{product.name}</span>
                            {product.selectedVariant && ` (${product.selectedVariant.nominal})`} {/* Display selected nominal */}
                        </p>
                        
                        <div className="my-4">
                            {appliedPromo ? (
                                <div>
                                    <span className="text-2xl text-secondary line-through">{convertPrice(product.selectedVariant ? product.selectedVariant.price : product.price, currency)}</span>
                                    <span className="text-4xl font-bold accent-text ml-2">{convertPrice(finalPrice, currency)}</span>
                                </div>
                            ) : (
                                <span className="text-4xl font-bold accent-text">{convertPrice(product.selectedVariant ? product.selectedVariant.price : product.price, currency)}</span>
                            )}
                        </div>

                        <div className="space-y-4">
                            <h3 className="text-xl text-primary">{t.choosePayment}</h3>
                            <div className="bg-tertiary p-4 rounded-lg">
                                <label className="block text-secondary text-sm font-bold mb-2">{t.payWithPromo}</label>
                                <div className="flex space-x-2">
                                    <input type="text" value={promoCode} onChange={(e) => setPromoCode(e.target.value.toUpperCase())} placeholder={t.promoCodeName} className="w-full p-2 bg-primary rounded-lg border-color text-primary"/>
                                    <button onClick={handleApplyPromo} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">{t.apply}</button>
                                </div>
                                {error && <p className="text-red-500 text-sm mt-2">{error}</p>}
                                {appliedPromo && <p className="text-green-500 text-sm mt-2">{t.promoApplied}: {appliedPromo.discount}%</p>}
                            </div>

                            <button onClick={handleContactSeller} className="w-full bg-teal-500 hover:bg-teal-600 text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105">{t.contactSeller}</button>
                            <button onClick={handleYooMoneyClick} className="w-full bg-yellow-500 hover:bg-yellow-600 text-black font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105">YooMoney</button>
                        </div>
                    </div>
                </Modal>
            );
        }

        function YooMoneyModal({ data, onClose, onSubmitReceipt, t, currency, convertPrice, setAlertInfo }) {
            const { product, purchaseDetails } = data;
            const [receiptFile, setReceiptFile] = useState(null);
            const [contactTelegram, setContactTelegram] = useState('');
            const [contactEmail, setContactEmail] = useState('');
            const [isUploading, setIsUploading] = useState(false);

            const handleFileChange = (e) => {
                if (e.target.files[0]) {
                    setReceiptFile(e.target.files[0]);
                }
            };

            const handleSubmit = async (e) => {
                e.preventDefault();
                if (!receiptFile || !contactTelegram || !contactEmail) {
                    setAlertInfo({ message: t.fillAllFields });
                    return;
                }
                setIsUploading(true);
                try {
                    await onSubmitReceipt(product, purchaseDetails, {
                        receiptFile,
                        contactTelegram,
                        contactEmail
                    });
                    onClose();
                } catch (error) {
                    // Error is already handled in the App component's handler
                } finally {
                    setIsUploading(false);
                }
            };

            return (
                <Modal onClose={onClose} size="max-w-lg">
                    <div className="text-center">
                        <h2 className="text-2xl font-bold text-primary mb-4">{t.yooMoneyPayment}</h2>
                        <p className="text-secondary mb-4">{t.yooMoneyInstruction}</p>
                        
                        {/* QR Code display removed as requested. You can re-add it here as an <img> tag pointing to a hosted image URL. */}
                        {/* Example: <img src="URL_TO_YOUR_QR_CODE.png" alt="YooMoney QR Code" className="w-48 h-48 mx-auto my-4 border-4 border-white rounded-lg"/> */}
                        
                        <div className="my-4">
                            <p className="text-secondary">{t.amountToPay}:</p>
                            <p className="text-3xl font-bold accent-text">{convertPrice(purchaseDetails.finalPrice, currency)}</p>
                        </div>
                        
                        <div className="bg-tertiary p-3 rounded-lg mb-6">
                            <p className="text-secondary text-sm">{t.orPayWithLink}:</p>
                            <a href="https://yoomoney.ru/to/4100118308403073/0" target="_blank" rel="noopener noreferrer" className="text-blue-400 hover:underline break-words">
                                https://yoomoney.ru/to/4100118308403073/0
                            </a>
                        </div>

                        <form onSubmit={handleSubmit} className="space-y-4 text-left">
                            <h3 className="text-xl font-bold text-primary text-center">{t.afterPaymentTitle}</h3>
                            <div>
                                <label className="block text-secondary mb-1">{t.telegramUsername}</label>
                                <input type="text" value={contactTelegram} onChange={e => setContactTelegram(e.target.value)} placeholder="@username" className="w-full p-2 bg-primary rounded-lg border-color text-primary"/>
                            </div>
                            <div>
                                <label className="block text-secondary mb-1">{t.contactEmail}</label>
                                <input type="email" value={contactEmail} onChange={e => setContactEmail(e.target.value)} placeholder="email@example.com" className="w-full p-2 bg-primary rounded-lg border-color text-primary"/>
                            </div>
                             <div>
                                <label className="block text-secondary mb-1">{t.uploadReceipt}</label>
                                <input type="file" onChange={handleFileChange} accept="image/*" className="w-full text-sm text-secondary file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-purple-50 file:text-purple-700 hover:file:bg-purple-100"/>
                            </div>
                            <button type="submit" disabled={isUploading} className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition-colors disabled:bg-gray-500">
                                {isUploading ? t.sending : t.sendForVerification}
                            </button>
                        </form>
                    </div>
                </Modal>
            );
        }

        function FAQPage({ faqs, t }) {
            const [openIndex, setOpenIndex] = useState(null);
            return (
                <div className="container mx-auto p-4 md:p-8">
                    <h1 className="text-4xl font-bold text-center mb-8 text-primary">{t.faqTitle}</h1>
                    <div className="space-y-4 max-w-3xl mx-auto">
                        {faqs.length === 0 ? (
                            <p className="text-center text-secondary text-xl mt-12">{t.noFaqs || 'FAQ не найдены.'}</p>
                        ) : (
                            faqs.map((faq, index) => (
                                <div key={faq.id} className="bg-secondary rounded-lg">
                                    <button onClick={() => setOpenIndex(openIndex === index ? null : index)} className="w-full text-left p-4 flex justify-between items-center">
                                        <span className="font-semibold text-primary">{faq.question}</span>
                                        <svg className={`w-6 h-6 transform transition-transform text-primary ${openIndex === index ? 'rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                                    </button>
                                    {openIndex === index && ( <div className="p-4 border-t border-color text-secondary"> {faq.answer} </div> )}
                                </div>
                            ))
                        )}
                    </div>
                </div>
            );
        }
        
        function MyPurchasesPage({ user, t, currency, convertPrice, setAlertInfo }) {
            const [myPurchases, setMyPurchases] = useState([]);
            const [loading, setLoading] = useState(true);
            const [dateFilter, setDateFilter] = useState('all');
            const [sortOrder, setSortOrder] = useState('date_desc');

            useEffect(() => {
                if (!user) { setLoading(false); return; }
                setLoading(true);
                const q = query(collection(db, "purchases"), where("userId", "==", user.uid));
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    const purchases = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setMyPurchases(purchases);
                    setLoading(false);
                }, (error) => {
                    console.error("Error fetching purchases:", error);
                    setLoading(false);
                });

                return () => unsubscribe();
            }, [user]);
            
            const filteredAndSortedPurchases = useMemo(() => {
                let items = [...myPurchases];
                if (dateFilter !== 'all') {
                    const now = new Date();
                    const filterDate = new Date();
                    if (dateFilter === 'today') {
                        filterDate.setHours(0, 0, 0, 0);
                    } else if (dateFilter === '3days') {
                        filterDate.setDate(now.getDate() - 3);
                        filterDate.setHours(0, 0, 0, 0);
                    }
                    items = items.filter(item => item.timestamp?.toDate && item.timestamp.toDate() >= filterDate);
                }
                if (sortOrder === 'price_asc') {
                    items.sort((a, b) => (a.finalPrice || 0) - (b.finalPrice || 0));
                } else {
                    items.sort((a, b) => (b.timestamp?.toMillis() || 0) - (a.timestamp?.toMillis() || 0));
                }
                return items;
            }, [myPurchases, dateFilter, sortOrder]);

            const handleCancelPurchase = (purchaseId) => {
                setAlertInfo({
                    message: t.confirmCancelPurchase,
                    onConfirm: async () => {
                        try {
                            await updateDoc(doc(db, 'purchases', purchaseId), { status: 'cancelled' });
                            setAlertInfo({ message: t.purchaseCancelled });
                        } catch (error) {
                            setAlertInfo({ message: t.errorOccurred });
                        }
                    }
                });
            };

            const getStatusClass = (status) => {
                switch (status) {
                    case 'approved': return 'bg-green-500';
                    case 'rejected': return 'bg-red-500';
                    case 'contacted': return 'bg-blue-500';
                    case 'cancelled': return 'bg-gray-500';
                    default: return 'bg-yellow-500'; // pending
                }
            };
            const getStatusText = (status) => {
                switch (status) {
                    case 'approved': return t.statusApproved;
                    case 'rejected': return t.statusRejected;
                    case 'contacted': return t.statusContacted;
                    case 'cancelled': return t.statusCancelled;
                    default: return t.statusPending;
                }
            };
            const FilterButton = ({ value, state, setState, children }) => (
                <button onClick={() => setState(value)} className={`px-4 py-2 rounded-lg text-sm transition-colors ${state === value ? 'accent-bg text-white' : 'bg-tertiary text-primary hover:bg-gray-600'}`}>
                    {children}
                </button>
            );

            return (
                <div className="container mx-auto p-4 md:p-8">
                    <h1 className="text-4xl font-bold text-center mb-8 text-primary">{t.myPurchases}</h1>
                    <div className="max-w-3xl mx-auto bg-secondary p-4 rounded-lg mb-6 flex flex-col sm:flex-row justify-between items-center gap-4">
                        <div className="flex items-center gap-2">
                           <span className="text-secondary font-semibold">{t.filterByDate}:</span>
                           <FilterButton value="all" state={dateFilter} setState={setDateFilter}>{t.all}</FilterButton>
                           <FilterButton value="today" state={dateFilter} setState={setDateFilter}>{t.today}</FilterButton>
                           <FilterButton value="3days" state={dateFilter} setState={setDateFilter}>{t.last3days}</FilterButton>
                        </div>
                         <div className="flex items-center gap-2">
                           <span className="text-secondary font-semibold">{t.sortBy}:</span>
                           <FilterButton value="date_desc" state={sortOrder} setState={setSortOrder}>{t.newSort}</FilterButton>
                           <FilterButton value="price_asc" state={sortOrder} setState={setSortOrder}>{t.priceAsc}</FilterButton>
                        </div>
                    </div>
                    {loading ? <LoadingSpinner /> : (
                        filteredAndSortedPurchases.length === 0 ? <p className="text-center text-secondary">{t.noPurchasesYet}</p> : (
                            <div className="space-y-4 max-w-3xl mx-auto">
                                {filteredAndSortedPurchases.map(purchase => (
                                    <div key={purchase.id} className="bg-secondary p-4 rounded-lg">
                                        <div className="flex justify-between items-start flex-wrap">
                                            <div>
                                                <p className="font-bold text-primary text-lg">{purchase.productName}</p>
                                                {purchase.nominal && <p className="text-sm text-secondary">{t.nominal}: {purchase.nominal}</p>}
                                                <p className="font-mono text-sm accent-text bg-tertiary inline-block px-2 py-1 rounded my-1">Код: {purchase.purchaseCode}</p>
                                                <p className="text-sm text-secondary">{purchase.timestamp?.toDate ? new Date(purchase.timestamp.toDate()).toLocaleString() : '...'}</p>
                                                <p className="text-sm text-secondary">{t.amount}: {convertPrice(purchase.finalPrice, currency)}</p>
                                            </div>
                                            <span className={`mt-2 sm:mt-0 px-2 py-1 text-xs font-bold text-white rounded-full ${getStatusClass(purchase.status)}`}>
                                                {getStatusText(purchase.status)}
                                            </span>
                                        </div>
                                        {purchase.adminComment && (
                                            <div className="mt-2 p-2 bg-tertiary rounded-md">
                                                <p className="text-sm text-secondary"><b>{t.adminComment}:</b> {purchase.adminComment}</p>
                                            </div>
                                        )}
                                        <div className="flex space-x-2 mt-4">
                                            {(purchase.status === 'approved' || purchase.status === 'contacted') && (
                                                <a href="https://t.me/asonikofficial" target="_blank" rel="noopener noreferrer" className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">
                                                    {t.contactSellerToReceive}
                                                </a>
                                            )}
                                            {purchase.status === 'contacted' && (
                                                <button onClick={() => handleCancelPurchase(purchase.id)} className="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">
                                                    {t.cancelOrder}
                                                </button>
                                            )}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )
                    )}
                </div>
            );
        }
        
        function Footer({t}) {
            return (
                <footer className="bg-secondary text-secondary p-6 mt-12 border-t border-color">
                    <div className="container mx-auto text-center">
                        <p>&copy; {new Date().getFullYear()} Asonik Store. {t.rightsReserved}</p>
                        <p className="text-sm mt-2">{t.developedWithLove}</p>
                    </div>
                </footer>
            );
        };

        // --- Admin Components ---
        function AdminProductManagement({ setAlertInfo, t, currency, convertPrice }) {
            const [products, setProducts] = useState([]);
            const [loading, setLoading] = useState(true);
            const [isModalOpen, setIsModalOpen] = useState(false);
            const [editingProduct, setEditingProduct] = useState(null);
            const [isSaving, setIsSaving] = useState(false); // New state for saving status

            const [name, setName] = useState('');
            const [description, setDescription] = useState('');
            const [category, setCategory] = useState('games');
            const [imageFiles, setImageFiles] = useState([]); // For new files to upload
            const [imageUrls, setImageUrls] = useState([]); // Existing image URLs from Firestore
            const [isVerified, setIsVerified] = useState(false);
            const [pinned, setPinned] = useState(false);
            const [isOnSale, setIsOnSale] = useState(true); // New state for sale status
            const [variants, setVariants] = useState([{ nominal: '', price: '', stockQuantity: 1 }]); // New state for variants
            const fileInputRef = useRef(null);


            const categories = [
                { value: 'games', label: t.games },
                { value: 'apps', label: t.apps },
                { value: 'other', label: t.other || 'Другое' }
            ];

            useEffect(() => {
                const q = query(collection(db, "products"), orderBy('createdAt', 'desc'));
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    setProducts(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
                    setLoading(false);
                }, (error) => {
                    console.error("Error fetching products for admin:", error);
                    setLoading(false);
                    setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                });
                return () => unsubscribe();
            }, []);

            const resetForm = () => {
                setEditingProduct(null);
                setName('');
                setDescription('');
                setCategory('games');
                setImageFiles([]);
                setImageUrls([]);
                setIsVerified(false);
                setPinned(false);
                setIsOnSale(true);
                setVariants([{ nominal: '', price: '', stockQuantity: 1 }]); // Reset variants
                if (fileInputRef.current) fileInputRef.current.value = "";
            };

            const uploadImageToImgBB = async (file) => {
                if (!IMGBB_API_KEY) {
                    throw new Error(t.noApiKey || 'API Key for ImgBB is not set!');
                }
                const formData = new FormData();
                formData.append('image', file);
                try {
                    const response = await fetch(`https://api.imgbb.com/1/upload?key=${IMGBB_API_KEY}`, {
                        method: 'POST',
                        body: formData,
                    });
                    const result = await response.json();
                    if (result.success) {
                        return result.data.url;
                    } else {
                        // Log full error response for debugging ImgBB issues
                        console.error("ImgBB API Error Response:", result);
                        throw new Error(result.error.message || 'ImgBB upload failed');
                    }
                } catch (error) {
                    console.error("ImgBB upload fetch error:", error);
                    throw error;
                }
            };

            const handleAddEditProduct = async (e) => {
                e.preventDefault();
                if (!name || !description || variants.length === 0 || variants.some(v => !v.nominal || v.price === '' || v.stockQuantity === '')) { // Price or stock can be 0 but not empty
                    setAlertInfo({ message: t.fillAllFields });
                    return;
                }

                setIsSaving(true); // Set saving state
                try {
                    const uploadedImgBBUrls = [];
                    for (const file of imageFiles) {
                        try {
                            const url = await uploadImageToImgBB(file); // Use ImgBB upload
                            uploadedImgBBUrls.push(url);
                        } catch (uploadError) {
                            // If one image fails, alert but try to continue with others or stop.
                            // For now, it will stop and show the error.
                            throw new Error(`${t.errorUploadingImage || 'Ошибка загрузки изображения'}: ${uploadError.message}`);
                        }
                    }
                    const finalImageUrls = [...imageUrls, ...uploadedImgBBUrls];

                    // Map variants prices to numbers and ensure stock is number
                    const processedVariants = variants.map(v => ({
                        ...v,
                        price: parseFloat(v.price),
                        stockQuantity: parseInt(v.stockQuantity) || 0 // Ensure stock is a number, default 0
                    }));


                    const productData = {
                        name, description, category,
                        imageUrls: finalImageUrls,
                        isVerified, pinned, isOnSale, variants: processedVariants
                    };

                    if (editingProduct) {
                        await updateDoc(doc(db, "products", editingProduct.id), { ...productData, updatedAt: serverTimestamp() });
                        setAlertInfo({ message: t.productUpdated });
                    } else {
                        await addDoc(collection(db, "products"), { ...productData, createdAt: serverTimestamp(), popularity: 0 });
                        setAlertInfo({ message: t.productAdded });
                    }
                    setIsModalOpen(false);
                    resetForm();
                } catch (error) {
                    console.error("Error saving product (overall):", error);
                    setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                } finally {
                    setIsSaving(false); // Reset saving state
                }
            };

            const handleEditClick = (product) => {
                setEditingProduct(product);
                setName(product.name);
                setDescription(product.description);
                setCategory(product.category || 'games');
                setImageUrls(product.imageUrls || (product.imageUrl ? [product.imageUrl] : []));
                setIsVerified(product.isVerified || false);
                setPinned(product.pinned || false);
                setIsOnSale(product.isOnSale !== false); // Default to true if not set
                // Convert price and stockQuantity to string for input fields
                setVariants(product.variants && product.variants.length > 0 ? 
                    product.variants.map(v => ({...v, price: String(v.price), stockQuantity: v.stockQuantity !== undefined ? String(v.stockQuantity) : '1'})) 
                    : [{ nominal: '', price: '', stockQuantity: '1' }]); // Load variants or default, convert stock to string
                setIsModalOpen(true);
            };

            const handleDeleteClick = (productId, productImages) => {
                setAlertInfo({
                    message: t.confirmDelete,
                    onConfirm: async () => {
                        try {
                            await deleteDoc(doc(db, "products", productId));
                            setAlertInfo({ message: t.productDeleted });
                        } catch (error) {
                            console.error("Error deleting product:", error);
                            setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                        }
                    }
                });
            };

            const handleCloneClick = async (productToClone) => {
                setAlertInfo({
                    message: t.confirmCloneProduct || `Вы уверены, что хотите клонировать товар "${productToClone.name}"?`,
                    onConfirm: async () => {
                        try {
                            const clonedProductData = {
                                ...productToClone,
                                name: `${productToClone.name} (${t.copyText || 'Копия'})`,
                                createdAt: serverTimestamp(), // New timestamp
                                updatedAt: serverTimestamp(), // New timestamp
                                popularity: 0, // Reset popularity for clone
                                isOnSale: true, // Cloned items are on sale by default
                                // Ensure variants are deep-copied and stock quantities are not references
                                variants: productToClone.variants ? productToClone.variants.map(v => ({ ...v, stockQuantity: v.stockQuantity || 0 })) : [],
                                // Do not copy ID, Firestore will generate a new one
                            };
                            delete clonedProductData.id; 

                            await addDoc(collection(db, "products"), clonedProductData);
                            setAlertInfo({ message: t.productCloned || 'Товар успешно клонирован!' });
                        } catch (error) {
                            console.error("Error cloning product:", error);
                            setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                        }
                    }
                });
            };

            const handleToggleSaleStatus = async (product) => {
                const newStatus = product.isOnSale === false; // If currently false, set to true, else false
                let updatedVariants = product.variants ? [...product.variants] : []; // Ensure variants array exists

                if (newStatus === true) {
                    const needsStockPrompt = updatedVariants.some(v => v.stockQuantity === undefined || v.stockQuantity <= 0);
                    if (needsStockPrompt || updatedVariants.length === 0) { // If no variants or some have no stock, prompt
                         // If no variants at all, add a default one to prompt for stock
                        if (updatedVariants.length === 0) {
                            updatedVariants.push({ nominal: t.defaultNominal || 'Базовый', price: product.price || 0, stockQuantity: 0 });
                        }

                        for (let i = 0; i < updatedVariants.length; i++) {
                            if (updatedVariants[i].stockQuantity === undefined || updatedVariants[i].stockQuantity <= 0) {
                                const enteredQuantity = prompt(`${t.enterStockQuantityForVariant || 'Введите количество товара в наличии для варианта'} "${updatedVariants[i].nominal || ' (без номинала)'}":`);
                                const quantityToSet = parseInt(enteredQuantity);
                                if (isNaN(quantityToSet) || quantityToSet < 0) {
                                    setAlertInfo({ message: t.invalidQuantity || 'Неверное количество. Товар не будет выставлен на продажу.' });
                                    return;
                                }
                                updatedVariants[i].stockQuantity = quantityToSet;
                            }
                        }
                    }
                }
                
                try {
                    await updateDoc(doc(db, "products", product.id), { 
                        isOnSale: newStatus,
                        variants: updatedVariants // Update variants with new stock quantities
                    });
                    setAlertInfo({ message: newStatus ? t.putOnSaleSuccess || 'Товар выставлен на продажу.' : t.removeFromSaleSuccess || 'Товар снят с продажи.' });
                } catch (error) {
                    console.error("Error toggling sale status:", error);
                    setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                }
            };

            const handleImageFileChange = (e) => {
                setImageFiles([...Array.from(e.target.files)]); // Replace current selection with new files
                if (fileInputRef.current) fileInputRef.current.value = ""; // Clear file input
            };

            const handleRemoveImage = (indexToRemove, isNewFile) => {
                if (isNewFile) {
                    setImageFiles(imageFiles.filter((_, index) => index !== indexToRemove));
                } else {
                    setImageUrls(imageUrls.filter((_, index) => index !== indexToRemove));
                }
            };

            const handleVariantChange = (index, field, value) => {
                const newVariants = [...variants];
                // Convert price and stockQuantity to numbers if not empty string
                if (field === 'price' || field === 'stockQuantity') {
                     newVariants[index][field] = value === '' ? '' : Number(value); 
                } else {
                    newVariants[index][field] = value;
                }
                setVariants(newVariants);
            };

            const handleAddVariant = () => {
                setVariants([...variants, { nominal: '', price: '', stockQuantity: 1 }]);
            };

            const handleRemoveVariant = (indexToRemove) => {
                setVariants(variants.filter((_, index) => index !== indexToRemove));
            };


            return (
                <div className="p-4 md:p-8 bg-secondary rounded-xl shadow-lg border-color min-h-[500px]">
                    <div className="flex justify-between items-center mb-6">
                        <h2 className="text-3xl font-bold text-primary">{t.manageProducts}</h2>
                        <button onClick={() => { resetForm(); setIsModalOpen(true); }} className="accent-bg hover:accent-bg-secondary text-white font-bold py-2 px-4 rounded-lg transition-colors flex items-center space-x-2">
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clipRule="evenodd" /></svg>
                            <span>{t.addProduct}</span>
                        </button>
                    </div>

                    {loading ? <LoadingSpinner /> : (
                        products.length === 0 ? <p className="text-center text-secondary text-xl mt-12">{t.productsNotFound}</p> : (
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                {products.map(product => (
                                    <div key={product.id} className="bg-tertiary rounded-lg p-4 shadow border-color flex flex-col">
                                        <div className="relative mb-3">
                                            <img src={(product.imageUrls && product.imageUrls.length > 0) ? product.imageUrls[0] : (product.imageUrl || '')} 
                                                 alt={product.name} 
                                                 className="w-full h-40 object-cover rounded-md" 
                                                 onError={(e) => { e.target.onerror = null; e.target.src=`https://placehold.co/600x400/374151/1f2937?text=${encodeURIComponent(t.imageNotFound)}`; }}/>
                                            {product.pinned && <span className="absolute top-2 right-2 bg-yellow-400 text-black text-xs font-bold px-2 py-1 rounded-full">{t.pinned}</span>}
                                            {product.isOnSale === false && <span className="absolute top-2 left-2 bg-gray-500 text-white text-xs font-bold px-2 py-1 rounded-full">{t.removedFromSale || 'Снято с продажи'}</span>}
                                        </div>
                                        <h3 className="text-xl font-bold text-primary mb-1">{product.name}</h3>
                                        {product.nominal && <p className="text-secondary text-sm mb-2">{product.nominal}</p>} {/* Keep for old products */}
                                        {product.variants && product.variants.length > 0 ? (
                                            <div className="text-secondary text-sm mb-2">
                                                {t.priceFrom}: {convertPrice(Math.min(...product.variants.map(v => v.price)), currency)}
                                                {product.variants.length > 1 && ` - ${convertPrice(Math.max(...product.variants.map(v => v.price)), currency)}`}
                                            </div>
                                        ) : (
                                            product.price && <p className="accent-text text-lg font-bold mt-auto">{convertPrice(product.price, currency)}</p>
                                        )}
                                        {/* Display total stock quantity from variants or general if exists */}
                                        {product.variants && product.variants.length > 0 && (
                                            <p className="text-secondary text-sm">
                                                {t.inStock || 'В наличии'}: {product.variants.reduce((sum, v) => sum + (parseInt(v.stockQuantity) || 0), 0) > 0 ? product.variants.reduce((sum, v) => sum + (parseInt(v.stockQuantity) || 0), 0) : t.outOfStock}
                                            </p>
                                        )}
                                        {!(product.variants && product.variants.length > 0) && product.stockQuantity !== undefined && ( // Fallback for old products
                                            <p className="text-secondary text-sm">
                                                {t.inStock || 'В наличии'}: {product.stockQuantity > 0 ? product.stockQuantity : t.outOfStock}
                                            </p>
                                        )}


                                        <div className="flex space-x-2 mt-4 flex-wrap">
                                            <button onClick={() => handleEditClick(product)} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors flex-grow mb-2">{t.edit}</button>
                                            <button onClick={() => handleDeleteClick(product.id, product.imageUrls || (product.imageUrl ? [product.imageUrl] : []))} className="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-colors flex-grow mb-2">{t.delete}</button>
                                            <button onClick={() => handleCloneClick(product)} className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors flex-grow mb-2">{t.cloneProduct || 'Клон'}</button>
                                            <button 
                                                onClick={() => handleToggleSaleStatus(product)} 
                                                className={`font-bold py-2 px-4 rounded-lg transition-colors flex-grow ${product.isOnSale === false ? 'bg-purple-600 hover:bg-purple-700 text-white' : 'bg-yellow-600 hover:bg-yellow-700 text-black'}`}>
                                                {product.isOnSale === false ? t.putOnSale || 'Вернуть в продажу' : t.removeFromSale || 'Снять с продажи'}
                                            </button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )
                    )}

                    {isModalOpen && (
                        <Modal onClose={() => { setIsModalOpen(false); resetForm(); }} size="max-w-2xl">
                            <h2 className="text-2xl font-bold text-primary mb-6 text-center">{editingProduct ? t.editProduct : t.addProduct}</h2>
                            <form onSubmit={handleAddEditProduct} className="space-y-4">
                                <div>
                                    <label className="block text-secondary text-sm font-bold mb-2">{t.productName}</label>
                                    <input type="text" value={name} onChange={(e) => setName(e.target.value)} className="w-full p-3 bg-tertiary rounded-lg border-color text-primary" placeholder={t.productName}/>
                                </div>
                                <div>
                                    <label className="block text-secondary text-sm font-bold mb-2">{t.description}</label>
                                    <textarea value={description} onChange={(e) => setDescription(e.target.value)} className="w-full p-3 bg-tertiary rounded-lg border-color text-primary h-32 resize-none" placeholder={t.description}></textarea>
                                </div>
                                <div>
                                    <label className="block text-secondary text-sm font-bold mb-2">{t.category}</label>
                                    <CustomSelector value={category} onChange={e => setCategory(e.target.value)} options={categories} />
                                </div>
                                
                                {/* Product Variants */}
                                <div className="space-y-3 bg-tertiary p-4 rounded-lg border-color">
                                    <h3 className="text-xl font-bold text-primary">{t.productVariants || 'Варианты товара'}</h3>
                                    {variants.map((variant, index) => (
                                        <div key={index} className="flex flex-col md:flex-row gap-2 items-end">
                                            <div className="flex-grow">
                                                <label className="block text-secondary text-sm mb-1">{t.nominal || 'Номинал'}</label>
                                                <input type="text" value={variant.nominal} onChange={(e) => handleVariantChange(index, 'nominal', e.target.value)} className="w-full p-2 bg-primary rounded-lg border-color text-primary" placeholder={t.nominalExample || '500 гемов'}/>
                                            </div>
                                            <div className="flex-grow">
                                                <label className="block text-secondary text-sm mb-1">{t.price || 'Цена'}</label>
                                                <input type="number" value={variant.price} onChange={(e) => handleVariantChange(index, 'price', e.target.value)} className="w-full p-2 bg-primary rounded-lg border-color text-primary" placeholder="100"/>
                                            </div>
                                            <div className="flex-grow">
                                                <label className="block text-secondary text-sm mb-1">{t.stockQuantity || 'Наличие'}</label>
                                                <input type="number" value={variant.stockQuantity} onChange={(e) => handleVariantChange(index, 'stockQuantity', e.target.value)} className="w-full p-2 bg-primary rounded-lg border-color text-primary" placeholder="1"/>
                                            </div>
                                            <button type="button" onClick={() => handleRemoveVariant(index)} className="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg h-10 flex-shrink-0">
                                                {t.remove || 'Удалить'}
                                            </button>
                                        </div>
                                    ))}
                                    <button type="button" onClick={handleAddVariant} className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg mt-2">
                                        {t.addVariant || 'Добавить вариант'}
                                    </button>
                                </div>

                                <div>
                                    <label className="block text-secondary text-sm font-bold mb-2">{t.productImages}</label>
                                    <div className="flex flex-wrap gap-2 mb-2">
                                        {imageUrls.map((url, index) => (
                                            <div key={`url-${index}`} className="relative w-24 h-24 rounded-lg overflow-hidden border border-color">
                                                <img src={url} alt={`Product Image ${index}`} className="w-full h-full object-cover"/>
                                                <button type="button" onClick={() => handleRemoveImage(index, false)} className="absolute top-0 right-0 bg-red-600 text-white rounded-bl-lg p-1 text-xs">X</button>
                                            </div>
                                        ))}
                                        {imageFiles.map((file, index) => (
                                            <div key={`file-${index}`} className="relative w-24 h-24 rounded-lg overflow-hidden border border-color">
                                                <img src={URL.createObjectURL(file)} alt={`New Image ${index}`} className="w-full h-full object-cover"/>
                                                <button type="button" onClick={() => handleRemoveImage(index, true)} className="absolute top-0 right-0 bg-red-600 text-white rounded-bl-lg p-1 text-xs">X</button>
                                            </div>
                                        ))}
                                    </div>
                                    <input type="file" ref={fileInputRef} onChange={handleImageFileChange} accept="image/*" multiple className="w-full text-sm text-secondary file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-purple-50 file:text-purple-700 hover:file:bg-purple-100"/>
                                </div>
                                <div className="flex items-center space-x-4">
                                    <label className="flex items-center text-secondary">
                                        <input type="checkbox" checked={isVerified} onChange={(e) => setIsVerified(e.target.checked)} className="form-checkbox h-5 w-5 text-purple-600 rounded"/>
                                        <span className="ml-2">{t.verifiedByStore}</span>
                                    </label>
                                    <label className="flex items-center text-secondary">
                                        <input type="checkbox" checked={pinned} onChange={(e) => setPinned(e.target.checked)} className="form-checkbox h-5 w-5 text-purple-600 rounded"/>
                                        <span className="ml-2">{t.pinProduct}</span>
                                    </label>
                                </div>
                                <button type="submit" disabled={isSaving} className="w-full accent-bg hover:accent-bg-secondary text-white font-bold py-3 px-4 rounded-lg transition-colors disabled:bg-gray-500">
                                    {isSaving ? t.sending : (editingProduct ? t.updateProduct : t.addProductBtn)}
                                </button>
                            </form>
                        </Modal>
                    )}
                </div>
            );
        }

        function AdminPromoCodeManagement({ setAlertInfo, t }) {
            const [promoCodes, setPromoCodes] = useState([]);
            const [loading, setLoading] = useState(true);
            const [isModalOpen, setIsModalOpen] = useState(false);
            const [editingPromoCode, setEditingPromoCode] = useState(null);

            const [code, setCode] = useState('');
            const [discount, setDiscount] = useState('');
            const [usageLimit, setUsageLimit] = useState('');
            const [isSaving, setIsSaving] = useState(false); // New state for saving status

            useEffect(() => {
                const q = query(collection(db, "promoCodes"), orderBy('createdAt', 'desc'));
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    setPromoCodes(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
                    setLoading(false);
                }, (error) => {
                    console.error("Error fetching promo codes for admin:", error);
                    setLoading(false);
                    setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                });
                return () => unsubscribe();
            }, []);

            const resetForm = () => {
                setEditingPromoCode(null);
                setCode('');
                setDiscount('');
                setUsageLimit('');
            };

            const handleAddEditPromoCode = async (e) => {
                e.preventDefault();
                if (!code || !discount || !usageLimit) {
                    setAlertInfo({ message: t.fillAllFields });
                    return;
                }

                setIsSaving(true); // Set saving state
                try {
                    const promoCodeData = {
                        code: code.toUpperCase(),
                        discount: parseFloat(discount),
                        usageLimit: parseInt(usageLimit),
                    };

                    if (editingPromoCode) {
                        await updateDoc(doc(db, "promoCodes", editingPromoCode.id), { ...promoCodeData, updatedAt: serverTimestamp() });
                        setAlertInfo({ message: t.promoUpdated || 'Промокод обновлен!' });
                    } else {
                        // Check if promo code already exists
                        const existingDoc = await getDoc(doc(db, "promoCodes", promoCodeData.code));
                        if (existingDoc.exists()) {
                            setAlertInfo({ message: 'Промокод с таким названием уже существует.' });
                            return;
                        }
                        await setDoc(doc(db, "promoCodes", promoCodeData.code), { ...promoCodeData, createdAt: serverTimestamp(), timesUsed: 0 }); // Use setDoc with custom ID
                        setAlertInfo({ message: t.promoAdded });
                    }
                    setIsModalOpen(false);
                    resetForm();
                } catch (error) {
                    console.error("Error saving promo code:", error);
                    setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                } finally {
                    setIsSaving(false); // Reset saving state
                }
            };

            const handleEditClick = (promo) => {
                setEditingPromoCode(promo);
                setCode(promo.code);
                setDiscount(promo.discount);
                setUsageLimit(promo.usageLimit);
                setIsModalOpen(true);
            };

            const handleDeleteClick = (promoId) => {
                setAlertInfo({
                    message: t.confirmDeletePromo,
                    onConfirm: async () => {
                        try {
                            await deleteDoc(doc(db, "promoCodes", promoId));
                            setAlertInfo({ message: t.promoDeleted });
                        } catch (error) {
                            console.error("Error deleting promo code:", error);
                            setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                        }
                    }
                });
            };

            return (
                <div className="p-4 md:p-8 bg-secondary rounded-xl shadow-lg border-color min-h-[500px]">
                    <div className="flex justify-between items-center mb-6">
                        <h2 className="text-3xl font-bold text-primary">{t.managePromoCodes}</h2>
                        <button onClick={() => { resetForm(); setIsModalOpen(true); }} className="accent-bg hover:accent-bg-secondary text-white font-bold py-2 px-4 rounded-lg transition-colors flex items-center space-x-2">
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clipRule="evenodd" /></svg>
                            <span>{t.addPromoCode}</span>
                        </button>
                    </div>

                    {loading ? <LoadingSpinner /> : (
                        promoCodes.length === 0 ? <p className="text-center text-secondary text-xl mt-12">{t.noPromoCodes || 'Промокоды не найдены.'}</p> : (
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                {promoCodes.map(promo => (
                                    <div key={promo.id} className="bg-tertiary rounded-lg p-4 shadow border-color flex flex-col">
                                        <h3 className="text-xl font-bold text-primary mb-1">{promo.code}</h3>
                                        <p className="text-secondary text-sm mb-1">{t.discount}: {promo.discount}%</p>
                                        <p className="text-secondary text-sm mb-2">{t.usageLimit}: {promo.timesUsed} / {promo.usageLimit}</p>
                                        <div className="flex space-x-2 mt-auto">
                                            <button onClick={() => handleEditClick(promo)} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors flex-grow">{t.edit}</button>
                                            <button onClick={() => handleDeleteClick(promo.id)} className="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-colors flex-grow">{t.delete}</button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )
                    )}

                    {isModalOpen && (
                        <Modal onClose={() => { setIsModalOpen(false); resetForm(); }} size="max-w-md">
                            <h2 className="text-2xl font-bold text-primary mb-6 text-center">{editingPromoCode ? (t.editPromoCode || 'Редактировать промокод') : t.addPromoCode}</h2>
                            <form onSubmit={handleAddEditPromoCode} className="space-y-4">
                                <div>
                                    <label className="block text-secondary text-sm font-bold mb-2">{t.promoCodeName}</label>
                                    <input type="text" value={code} onChange={(e) => setCode(e.target.value.toUpperCase())} className="w-full p-3 bg-tertiary rounded-lg border-color text-primary" placeholder="PROMOCODE" disabled={!!editingPromoCode}/>
                                </div>
                                <div>
                                    <label className="block text-secondary text-sm font-bold mb-2">{t.discountPercentage}</label>
                                    <input type="number" value={discount} onChange={(e) => setDiscount(e.target.value)} className="w-full p-3 bg-tertiary rounded-lg border-color text-primary" placeholder="10" min="1" max="100"/>
                                </div>
                                <div>
                                    <label className="block text-secondary text-sm font-bold mb-2">{t.usageLimit}</label>
                                    <input type="number" value={usageLimit} onChange={(e) => setUsageLimit(e.target.value)} className="w-full p-3 bg-tertiary rounded-lg border-color text-primary" placeholder="100" min="1"/>
                                </div>
                                <button type="submit" disabled={isSaving} className="w-full accent-bg hover:accent-bg-secondary text-white font-bold py-3 px-4 rounded-lg transition-colors disabled:bg-gray-500">
                                    {isSaving ? t.sending : (editingPromoCode ? (t.updatePromo || 'Обновить промокод') : t.addPromoCode)}
                                </button>
                            </form>
                        </Modal>
                    )}
                </div>
            );
        }

        // New Admin FAQ Management Component
        function AdminFaqManagement({ setAlertInfo, t }) {
            const [faqs, setFaqs] = useState([]);
            const [loading, setLoading] = useState(true);
            const [isModalOpen, setIsModalOpen] = useState(false);
            const [editingFaq, setEditingFaq] = useState(null);

            const [question, setQuestion] = useState('');
            const [answer, setAnswer] = useState('');
            const [isSaving, setIsSaving] = useState(false);

            useEffect(() => {
                const q = query(collection(db, "faq"), orderBy('createdAt', 'asc'));
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    setFaqs(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
                    setLoading(false);
                }, (error) => {
                    console.error("Error fetching FAQs for admin:", error);
                    setLoading(false);
                    setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                });
                return () => unsubscribe();
            }, []);

            const resetForm = () => {
                setEditingFaq(null);
                setQuestion('');
                setAnswer('');
            };

            const handleAddEditFaq = async (e) => {
                e.preventDefault();
                if (!question || !answer) {
                    setAlertInfo({ message: t.fillAllFields });
                    return;
                }

                setIsSaving(true);
                try {
                    const faqData = { question, answer };
                    if (editingFaq) {
                        await updateDoc(doc(db, "faq", editingFaq.id), { ...faqData, updatedAt: serverTimestamp() });
                        setAlertInfo({ message: t.faqUpdated || 'FAQ обновлен!' });
                    } else {
                        await addDoc(collection(db, "faq"), { ...faqData, createdAt: serverTimestamp() });
                        setAlertInfo({ message: t.faqAdded || 'FAQ добавлен!' });
                    }
                    setIsModalOpen(false);
                    resetForm();
                } catch (error) {
                    console.error("Error saving FAQ:", error);
                    setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                } finally {
                    setIsSaving(false);
                }
            };

            const handleEditClick = (faq) => {
                setEditingFaq(faq);
                setQuestion(faq.question);
                setAnswer(faq.answer);
                setIsModalOpen(true);
            };

            const handleDeleteClick = (faqId) => {
                setAlertInfo({
                    message: t.confirmDeleteFaq || 'Вы уверены, что хотите удалить этот FAQ?',
                    onConfirm: async () => {
                        try {
                            await deleteDoc(doc(db, "faq", faqId));
                            setAlertInfo({ message: t.faqDeleted || 'FAQ удален.' });
                        } catch (error) {
                            console.error("Error deleting FAQ:", error);
                            setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                        }
                    }
                });
            };

            const handleClearAllFaqs = async () => {
                setAlertInfo({
                    message: t.confirmClearAllFaqs || 'Вы уверены, что хотите удалить ВСЕ FAQ? Это действие необратимо!',
                    onConfirm: async () => {
                        setIsSaving(true); // Use saving state for mass delete
                        try {
                            const querySnapshot = await getDocs(collection(db, "faq"));
                            const deletePromises = [];
                            querySnapshot.forEach((docToDelete) => {
                                deletePromises.push(deleteDoc(doc(db, "faq", docToDelete.id)));
                            });
                            await Promise.all(deletePromises);
                            setAlertInfo({ message: t.allFaqsCleared || 'Все FAQ успешно удалены.' });
                        } catch (error) {
                            console.error("Error clearing all FAQs:", error);
                            setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                        } finally {
                            setIsSaving(false);
                        }
                    }
                });
            };

            return (
                <div className="p-4 md:p-8 bg-secondary rounded-xl shadow-lg border-color min-h-[500px]">
                    <div className="flex justify-between items-center mb-6">
                        <h2 className="text-3xl font-bold text-primary">{t.manageFaq}</h2>
                        <div className="flex space-x-2">
                            <button onClick={() => { resetForm(); setIsModalOpen(true); }} className="accent-bg hover:accent-bg-secondary text-white font-bold py-2 px-4 rounded-lg transition-colors flex items-center space-x-2">
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clipRule="evenodd" /></svg>
                                <span>{t.addFaq || 'Добавить FAQ'}</span>
                            </button>
                            <button onClick={handleClearAllFaqs} disabled={isSaving} className="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:bg-gray-500">
                                {t.clearAllFaqs || 'Очистить все FAQ'}
                            </button>
                        </div>
                    </div>

                    {loading ? <LoadingSpinner /> : (
                        faqs.length === 0 ? <p className="text-center text-secondary text-xl mt-12">{t.noFaqs || 'FAQ не найдены.'}</p> : (
                            <div className="space-y-4">
                                {faqs.map(faq => (
                                    <div key={faq.id} className="bg-tertiary rounded-lg p-4 shadow border-color">
                                        <h3 className="text-xl font-bold text-primary mb-2">{faq.question}</h3>
                                        <p className="text-secondary text-sm mb-4">{faq.answer}</p>
                                        <div className="flex space-x-2">
                                            <button onClick={() => handleEditClick(faq)} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">{t.edit}</button>
                                            <button onClick={() => handleDeleteClick(faq.id)} className="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">{t.delete}</button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )
                    )}

                    {isModalOpen && (
                        <Modal onClose={() => { setIsModalOpen(false); resetForm(); }} size="max-w-2xl">
                            <h2 className="text-2xl font-bold text-primary mb-6 text-center">{editingFaq ? (t.editFaq || 'Редактировать FAQ') : (t.addFaq || 'Добавить FAQ')}</h2>
                            <form onSubmit={handleAddEditFaq} className="space-y-4">
                                <div>
                                    <label className="block text-secondary text-sm font-bold mb-2">{t.question || 'Вопрос'}</label>
                                    <input type="text" value={question} onChange={(e) => setQuestion(e.target.value)} className="w-full p-3 bg-tertiary rounded-lg border-color text-primary" placeholder={t.question || 'Введите вопрос'}/>
                                </div>
                                <div>
                                    <label className="block text-secondary text-sm font-bold mb-2">{t.answer || 'Ответ'}</label>
                                    <textarea value={answer} onChange={(e) => setAnswer(e.target.value)} className="w-full p-3 bg-tertiary rounded-lg border-color text-primary h-32 resize-none" placeholder={t.answer || 'Введите ответ'}></textarea>
                                </div>
                                <button type="submit" disabled={isSaving} className="w-full accent-bg hover:accent-bg-secondary text-white font-bold py-3 px-4 rounded-lg transition-colors disabled:bg-gray-500">
                                    {isSaving ? t.sending : (editingFaq ? (t.updateFaq || 'Обновить FAQ') : (t.addFaq || 'Добавить FAQ'))}
                                </button>
                            </form>
                        </Modal>
                    )}
                </div>
            );
        }

        // New Admin Receipt Check Component
        function AdminReceiptCheck({ setAlertInfo, t, currency, convertPrice }) {
            const [pendingPurchases, setPendingPurchases] = useState([]);
            const [loading, setLoading] = useState(true);
            const [selectedReceipt, setSelectedReceipt] = useState(null); // For viewing full receipt image
            const [adminComment, setAdminComment] = useState('');
            const [isUpdatingStatus, setIsUpdatingStatus] = useState(false);

            useEffect(() => {
                const q = query(collection(db, "purchases"), where("status", "==", "pending"), orderBy('timestamp', 'desc'));
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    setPendingPurchases(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
                    setLoading(false);
                }, (error) => {
                    console.error("Error fetching pending purchases:", error);
                    setLoading(false);
                    setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                });
                return () => unsubscribe();
            }, []);

            const handleStatusUpdate = async (purchaseId, status) => {
                setIsUpdatingStatus(true);
                try {
                    await updateDoc(doc(db, "purchases", purchaseId), { 
                        status: status, 
                        adminComment: adminComment || null, // Add admin comment
                        updatedAt: serverTimestamp() 
                    });
                    setAlertInfo({ message: status === 'approved' ? t.purchaseApproved || 'Покупка одобрена!' : t.purchaseRejected || 'Покупка отклонена.' });
                    setSelectedReceipt(null); // Close modal
                    setAlertInfo(null); // Clear previous alert
                    setAdminComment(''); // Clear comment
                } catch (error) {
                    console.error("Error updating purchase status:", error);
                    setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                } finally {
                    setIsUpdatingStatus(false);
                }
            };

            return (
                <div className="p-4 md:p-8 bg-secondary rounded-xl shadow-lg border-color min-h-[500px]">
                    <h2 className="text-3xl font-bold text-primary mb-6">{t.checkReceipts}</h2>

                    {loading ? <LoadingSpinner /> : (
                        pendingPurchases.length === 0 ? <p className="text-center text-secondary text-xl mt-12">{t.noPendingReceipts}</p> : (
                            <div className="space-y-4">
                                {pendingPurchases.map(purchase => (
                                    <div key={purchase.id} className="bg-tertiary rounded-lg p-4 shadow border-color">
                                        <p className="font-bold text-primary text-lg">{purchase.productName}</p>
                                        <p className="text-secondary text-sm">{t.user}: {purchase.userEmail}</p>
                                        <p className="text-secondary text-sm">{t.amount}: {convertPrice(purchase.finalPrice, currency)}</p>
                                        <p className="text-sm text-secondary mb-2">{t.date}: {purchase.timestamp?.toDate ? new Date(purchase.timestamp.toDate()).toLocaleString() : '...'}</p>
                                        <p className="font-mono text-sm accent-text bg-gray-600 inline-block px-2 py-1 rounded my-1">Код: {purchase.purchaseCode}</p>

                                        {purchase.receiptImageUrl && (
                                            <button onClick={() => setSelectedReceipt(purchase)} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg mt-2 transition-colors">
                                                {t.viewReceipt || 'Посмотреть чек'}
                                            </button>
                                        )}
                                    </div>
                                ))}
                            </div>
                        )
                    )}

                    {selectedReceipt && (
                        <Modal onClose={() => { setSelectedReceipt(null); setAdminComment(''); }} size="max-w-3xl">
                            <h2 className="text-2xl font-bold text-primary mb-4 text-center">{t.receiptDetails || 'Детали чека'}</h2>
                            <p className="text-secondary mb-2">{t.product}: <span className="font-semibold">{selectedReceipt.productName}</span></p>
                            <p className="text-secondary mb-2">{t.user}: <span className="font-semibold">{selectedReceipt.userEmail}</span></p>
                            <p className="text-secondary mb-4">{t.amount}: <span className="font-semibold accent-text">{convertPrice(selectedReceipt.finalPrice, currency)}</span></p>
                            
                            <img src={selectedReceipt.receiptImageUrl} alt="Receipt" className="w-full h-auto object-contain max-h-96 rounded-lg mb-4"/>

                            <div className="mb-4">
                                <label className="block text-secondary text-sm font-bold mb-2">{t.adminComment}</label>
                                <textarea value={adminComment} onChange={(e) => setAdminComment(e.target.value)} className="w-full p-3 bg-tertiary rounded-lg border-color text-primary h-24 resize-none" placeholder={t.adminCommentPlaceholder || 'Оставьте комментарий (необязательно)'}></textarea>
                            </div>

                            <div className="flex justify-between space-x-4">
                                <button onClick={() => handleStatusUpdate(selectedReceipt.id, 'rejected')} disabled={isUpdatingStatus} className="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:bg-gray-500 flex-grow">
                                    {isUpdatingStatus && selectedReceipt.status === 'rejected' ? t.sending : t.reject}
                                </button>
                                <button onClick={() => handleStatusUpdate(selectedReceipt.id, 'approved')} disabled={isUpdatingStatus} className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:bg-gray-500 flex-grow">
                                    {isUpdatingStatus && selectedReceipt.status === 'approved' ? t.sending : t.approve}
                                </button>
                            </div>
                        </Modal>
                    )}
                </div>
            );
        }

        // New Chat Components
        // This component will now handle displaying messages for a specific chat ID.
        // It will be reused for both admin chat and user-to-user chats.
        function ChatWindow({ currentUser, setAlertInfo, t, onClose, chatId, chatType, participantInfo }) { 
            const [messages, setMessages] = useState([]);
            const [newMessage, setNewMessage] = useState('');
            const [loadingMessages, setLoadingMessages] = useState(true);
            const messagesEndRef = useRef(null);

            const isCurrentUserAdmin = currentUser.uid === ADMIN_UID;
            const chatCollectionPath = chatType === 'admin' ? `chats/${currentUser.uid}/messages` : `userChats/${chatId}/messages`;

            useEffect(() => {
                if (!currentUser || !chatId) { setLoadingMessages(false); return; }

                setLoadingMessages(true);
                const q = query(
                    collection(db, chatCollectionPath),
                    orderBy('timestamp', 'asc')
                );
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    setMessages(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
                    setLoadingMessages(false);

                    // Mark messages as read for the current user
                    const unreadMessages = snapshot.docs.filter(doc => {
                        const data = doc.data();
                        if (chatType === 'admin') {
                            // If it's an admin chat, user marks admin's messages as read.
                            return data.isAdmin && !data.isRead; 
                        } else {
                            // For user-to-user chat, mark messages from other participant as read.
                            return data.senderId !== currentUser.uid && !data.isRead;
                        }
                    });

                    unreadMessages.forEach(async (msgDoc) => {
                        await updateDoc(doc(db, chatCollectionPath, msgDoc.id), { isRead: true });
                    });

                    // Update main chat document to reflect read status for the current user
                    if (chatType === 'admin') {
                        // Mark hasUnreadUser as false for the user when they read admin messages
                        // Need to check if the chat document exists before updating
                        getDoc(doc(db, "chats", currentUser.uid)).then(chatDocSnap => {
                            if(chatDocSnap.exists()) {
                                updateDoc(doc(db, "chats", currentUser.uid), { hasUnreadUser: false });
                            }
                        }).catch(error => console.error("Error checking admin chat doc existence:", error));
                    } else {
                        // For user-to-user chats, update hasUnread[currentUser.uid] to false
                        getDoc(doc(db, "userChats", chatId)).then(chatDocSnap => {
                            if(chatDocSnap.exists()) {
                                updateDoc(doc(db, "userChats", chatId), { [`hasUnread.${currentUser.uid}`]: false });
                            }
                        }).catch(error => console.error("Error checking user chat doc existence:", error));
                    }

                }, (error) => {
                    console.error("Error fetching chat messages:", error);
                    setLoadingMessages(false);
                    setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                });
                return () => unsubscribe();
            }, [currentUser, chatId, chatType]);

            useEffect(() => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            }, [messages]);

            const sendMessage = async (e) => {
                e.preventDefault();
                if (newMessage.trim() === '' || !currentUser) return;

                try {
                    // Check if chat document exists, especially for admin chat to ensure it's created if first message
                    if (chatType === 'admin') {
                        const adminChatDocRef = doc(db, "chats", currentUser.uid);
                        const adminChatDocSnap = await getDoc(adminChatDocRef);
                        if (!adminChatDocSnap.exists()) {
                            // Create the main admin chat document if it doesn't exist
                            await setDoc(adminChatDocRef, {
                                userId: currentUser.uid,
                                userName: currentUser.displayName || currentUser.email,
                                userEmail: currentUser.email,
                                createdAt: serverTimestamp(),
                                lastMessage: "", // Initial empty last message
                                lastMessageTimestamp: serverTimestamp(),
                                hasUnreadAdmin: false,
                                hasUnreadUser: false,
                            });
                        }
                    }

                    await addDoc(collection(db, chatCollectionPath), {
                        senderId: currentUser.uid,
                        senderName: currentUser.displayName || currentUser.email,
                        message: newMessage,
                        timestamp: serverTimestamp(), // Use serverTimestamp for message creation
                        isRead: false,
                        isAdmin: isCurrentUserAdmin 
                    });

                    // Update the last message and timestamp in the main chat document
                    if (chatType === 'admin') {
                        await updateDoc(doc(db, "chats", currentUser.uid), {
                            lastMessage: newMessage,
                            lastMessageTimestamp: serverTimestamp(),
                            hasUnreadAdmin: isCurrentUserAdmin ? false : true, 
                            hasUnreadUser: isCurrentUserAdmin ? true : false, 
                        });
                    } else { // User-to-user chat
                        const updateData = {
                            lastMessage: newMessage,
                            lastMessageTimestamp: serverTimestamp(),
                            [`hasUnread.${currentUser.uid}`]: false, // Current user sent, so they read it
                        };
                        // Mark other participants as unread
                        if (participantInfo && participantInfo.participants && Array.isArray(participantInfo.participants)) {
                            participantInfo.participants.forEach(pId => {
                                if (pId !== currentUser.uid) {
                                    updateData[`hasUnread.${pId}`] = true;
                                }
                            });
                        }
                        await updateDoc(doc(db, "userChats", chatId), updateData);
                    }

                    setNewMessage('');
                } catch (error) {
                    console.error("Error sending message:", error);
                    setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                }
            };

            const chatTitle = chatType === 'admin' ? t.chatWithAdmin : (participantInfo?.displayPeerName || t.chatWithUser || 'Чат с пользователем');

            return (
                <Modal onClose={onClose} size="max-w-4xl">
                    <h2 className="text-2xl font-bold text-primary mb-4 text-center">{chatTitle}</h2>
                    <div className="flex-grow overflow-y-auto pr-2 mb-4 space-y-4 h-96">
                        {loadingMessages ? <LoadingSpinner /> : (
                            messages.length === 0 ? (
                                <p className="text-center text-secondary text-xl mt-12">{t.noChatMessages}</p>
                            ) : (
                                messages.map((msg) => (
                                    <div key={msg.id} className={`flex ${msg.senderId === currentUser.uid ? 'justify-end' : 'justify-start'}`}>
                                        <div className={`${msg.senderId === currentUser.uid ? 'accent-bg text-white rounded-bl-none' : 'bg-tertiary rounded-br-none'} max-w-[75%] p-3 rounded-lg shadow`}>
                                            <p className="font-bold text-sm mb-1">{msg.senderId === currentUser.uid ? t.you : (msg.senderName || t.user)}</p>
                                            <p>{msg.message}</p>
                                            <p className="text-xs mt-1 text-right opacity-70">
                                                {msg.timestamp?.toDate ? new Date(msg.timestamp.toDate()).toLocaleTimeString() : ''}
                                            </p>
                                        </div>
                                    </div>
                                ))
                            )
                        )}
                        <div ref={messagesEndRef} />
                    </div>
                    <form onSubmit={sendMessage} className="flex">
                        <input
                            type="text"
                            value={newMessage}
                            onChange={(e) => setNewMessage(e.target.value)}
                            placeholder={t.enterMessagePlaceholder}
                            className="flex-grow p-3 bg-tertiary rounded-l-lg border-color text-primary focus:outline-none focus:ring-2 accent-border"
                            disabled={!currentUser}
                        />
                        <button type="submit" className="accent-bg hover:accent-bg-secondary text-white font-bold py-3 px-6 rounded-r-lg transition-colors disabled:bg-gray-500" disabled={!currentUser}>
                            {t.send || 'Отправить'}
                        </button>
                    </form>
                    {!currentUser && <p className="text-red-500 text-center text-sm mt-2">{t.loginForSupport}</p>}
                </Modal>
            );
        }


        // --- New Chats Page Component ---
        function ChatsPage({ user, setAlertInfo, t }) {
            const [isChatWindowOpen, setIsChatWindowOpen] = useState(false); 
            const [currentChatInfo, setCurrentChatInfo] = useState(null); 
            const [loadingChats, setLoadingChats] = useState(true); 
            const [activeChats, setActiveChats] = useState([]); 
            const [isFindUserModalOpen, setIsFindUserModalOpen] = useState(false); 
            const [searchUserId, setSearchUserId] = useState('');
            const [foundUser, setFoundUser] = useState(null);
            const [searchError, setSearchError] = useState('');
            const [loadingRequests, setLoadingRequests] = useState(true);
            const [incomingRequests, setIncomingRequests] = useState([]);
            const [outgoingRequests, setOutgoingRequests] = useState([]);


            useEffect(() => {
                if (!user) { 
                    setLoadingChats(false);
                    setLoadingRequests(false);
                    setActiveChats([]);
                    setIncomingRequests([]);
                    setOutgoingRequests([]);
                    return; 
                }
                
                const unsubscribe = onSnapshot(doc(db, "users", user.uid), async (userDocSnap) => {
                    if (!userDocSnap.exists()) {
                        // If user document doesn't exist, create it with initial empty arrays
                        await setDoc(doc(db, "users", user.uid), { 
                            friends: [], 
                            friendRequests: [] 
                        }, { merge: true });

                        setLoadingRequests(false);
                        setLoadingChats(false);
                        return;
                    }

                    const userData = userDocSnap.data();
                    const friendsList = userData.friends || []; // Ensure it's an array, default to empty
                    const requests = userData.friendRequests || []; // Ensure it's an array, default to empty

                    // Fetch details for friends - NOT needed directly in ChatsPage for friend list
                    // Instead, focus on requests and chats

                    // Separate incoming and outgoing requests
                    const incoming = [];
                    const outgoing = [];

                    const requestPromises = requests.map(async (req) => {
                        // Ensure timestamp is a Date object if it's a Firestore Timestamp
                        const requestWithDate = { ...req, timestamp: req.timestamp && typeof req.timestamp.toDate === 'function' ? req.timestamp.toDate() : new Date(req.timestamp.seconds * 1000 + req.timestamp.nanoseconds / 1000000) };

                        const peerId = requestWithDate.from === user.uid ? requestWithDate.to : requestWithDate.from;
                        const peerSnap = await getDoc(doc(db, "users", peerId));
                        const peerData = peerSnap.exists() ? (peerSnap.data().displayName || peerSnap.data().email) : t.unknownUser;
                        
                        if (requestWithDate.to === user.uid) { // Incoming request
                            incoming.push({ ...requestWithDate, peerName: peerData, peerId: peerId });
                        } else { // Outgoing request
                            outgoing.push({ ...requestWithDate, peerName: peerData, peerId: peerId });
                        }
                    });
                    await Promise.all(requestPromises);
                    setIncomingRequests(incoming.sort((a,b) => b.timestamp.getTime() - a.timestamp.getTime()));
                    setOutgoingRequests(outgoing.sort((a,b) => b.timestamp.getTime() - a.timestamp.getTime()));
                    setLoadingRequests(false);


                    // Fetch active chats (where the current user is a participant and not a pending request)
                    const userChatsQuery = query(collection(db, "userChats"), where("participants", "array-contains", user.uid));
                    const unsubscribeUserChats = onSnapshot(userChatsQuery, async (userChatsSnapshot) => {
                        const activeUserChatsData = await Promise.all(userChatsSnapshot.docs
                            .filter(docSnap => {
                                const chatData = docSnap.data();
                                // Filter out chats that are solely pending friend requests
                                return !chatData.requests || chatData.requests.every(req => req.status !== 'pending');
                            })
                            .map(async (docSnap) => {
                                const chatData = docSnap.data();
                                const otherParticipantId = chatData.participants.find(pId => pId !== user.uid);
                                let displayPeerName = '';
                                if (otherParticipantId) {
                                    const otherUserDoc = await getDoc(doc(db, 'users', otherParticipantId));
                                    displayPeerName = otherUserDoc.exists() ? (otherUserDoc.data().displayName || otherUserDoc.data().email) : t.unknownUser;
                                } else {
                                    displayPeerName = chatData.name || t.groupChat; 
                                }
                                const hasUnread = chatData.hasUnread && chatData.hasUnread[user.uid];
                                return { 
                                    id: docSnap.id, 
                                    ...chatData, 
                                    type: 'userToUser', 
                                    displayPeerName,
                                    hasUnread,
                                    sortTimestamp: chatData.lastMessageTimestamp || chatData.createdAt,
                                };
                            }));
                        
                        // Handle admin chat separately
                        const adminChatQuery = query(collection(db, "chats"), where("userId", "==", user.uid));
                        const adminChatSnapshot = await getDocs(adminChatQuery);
                        const adminChatDoc = adminChatSnapshot.docs.length > 0 ? { 
                            id: adminChatSnapshot.docs[0].id, 
                            ...adminChatSnapshot.docs[0].data(), 
                            type: 'admin', 
                            displayPeerName: t.projectAdmin,
                            hasUnread: adminChatSnapshot.docs[0].data().hasUnreadUser, // For user to see unread from admin
                        } : null;

                        const combinedChats = [];
                        if (adminChatDoc) combinedChats.push(adminChatDoc);
                        combinedChats.push(...activeUserChats);

                        combinedChats.sort((a, b) => {
                            const tsA = a.lastMessageTimestamp && typeof a.lastMessageTimestamp.toMillis === 'function' ? a.lastMessageTimestamp.toMillis() : a.createdAt && typeof a.createdAt.toMillis === 'function' ? a.createdAt.toMillis() : 0;
                            const tsB = b.lastMessageTimestamp && typeof b.lastMessageTimestamp.toMillis === 'function' ? b.lastMessageTimestamp.toMillis() : b.createdAt && typeof b.createdAt.toMillis === 'function' ? b.createdAt.toMillis() : 0;
                            return tsB - tsA;
                        });

                        setActiveChats(combinedChats);
                        setLoadingChats(false);
                    }, (error) => {
                        console.error("Error fetching user-to-user chats:", error);
                        setLoadingChats(false);
                    });
                    
                    return () => unsubscribeUserChats(); // Cleanup for userChats listener
                }, (error) => {
                    console.error("Error fetching user data/friend data:", error);
                    setLoadingRequests(false);
                    setLoadingChats(false);
                });

                return () => unsubscribe(); // Cleanup for main user doc listener
            }, [user]);

            const copyUserIdToClipboard = () => {
                if (user && user.uid) {
                    navigator.clipboard.writeText(user.uid).then(() => {
                        setAlertInfo({ message: t.idCopied || 'ID скопирован в буфер обмена!' });
                    }, (err) => {
                        console.error('Could not copy text: ', err);
                    });
                }
            };

            const handleFindUserById = async () => {
                setFoundUser(null);
                setSearchError('');

                if (!searchUserId.trim()) {
                    setSearchError(t.enterUserIdToFind || 'Введите ID пользователя для поиска.');
                    return;
                }

                if (searchUserId === user.uid) {
                    setSearchError(t.cannotAddSelf || 'Вы не можете добавить себя в друзья.');
                    return;
                }
                
                // Check if already friends
                if (friends.some(f => f.id === searchUserId)) {
                    setSearchError(t.alreadyFriends || 'Этот пользователь уже у вас в друзьях.');
                    return;
                }

                // Check for pending requests (incoming or outgoing)
                if (incomingRequests.some(req => req.from === searchUserId && req.to === user.uid && req.status === 'pending') ||
                    outgoingRequests.some(req => req.from === user.uid && req.to === searchUserId && req.status === 'pending')) {
                    setSearchError(t.pendingRequestExists || 'Запрос дружбы с этим пользователем уже отправлен или находится на рассмотрении.');
                    return;
                }


                try {
                    const userDocRef = doc(db, 'users', searchUserId);
                    const userDocSnap = await getDoc(userDocRef);

                    if (userDocSnap.exists()) {
                        setFoundUser({ id: userDocSnap.id, ...userDocSnap.data() });
                    } else {
                        setSearchError(t.userNotFound || 'Пользователь с таким ID не найден.');
                    }
                } catch (error) {
                    console.error("Error searching user by ID:", error);
                    setSearchError(`${t.errorOccurred}: ${error.message}`);
                }
            };

            const handleSendFriendRequest = async (targetUser) => {
                if (!user || !targetUser) return;

                try {
                    // Create a new document in the friendRequests collection
                    const newRequestDocRef = await addDoc(collection(db, 'friendRequests'), {
                        from: user.uid,
                        to: targetUser.id,
                        status: 'pending',
                        timestamp: serverTimestamp() // Use serverTimestamp here
                    });
                    
                    // Optionally, you might still want to track these in user documents for simpler retrieval
                    // If you want to use arrayUnion/arrayRemove in users doc, use new Date() for timestamp as discussed
                    // But if it's only in friendRequests collection, serverTimestamp is fine.
                    // For now, let's just stick to the new collection for simplicity and to avoid arrayUnion timestamp issues.

                    setAlertInfo({ message: `${t.friendRequestSent || 'Запрос дружбы отправлен пользователю:'} ${targetUser.displayName || targetUser.email}` });
                    setFoundUser(null);
                    setSearchUserId('');
                    setIsFindUserModalOpen(false);
                } catch (error) {
                    console.error("Error sending friend request:", error);
                    setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                }
            };

            const handleAcceptFriendRequest = async (request) => {
                if (!user) return;
                try {
                    const friendRequestDocRef = doc(db, 'friendRequests', request.id); // Use request.id for the document ID

                    // Update the status of the request document
                    await updateDoc(friendRequestDocRef, { status: 'accepted' });

                    // Add to friends list for both users
                    const userDocRef = doc(db, 'users', user.uid);
                    const requesterUserDocRef = doc(db, 'users', request.from);
                    
                    await updateDoc(userDocRef, { friends: [...(await getDoc(userDocRef)).data().friends || [], request.from] });
                    await updateDoc(requesterUserDocRef, { friends: [...(await getDoc(requesterUserDocRef)).data().friends || [], user.uid] });

                    // Optionally create a chat document for them automatically
                    // Check if chat already exists
                    const existingChatQuery = query(collection(db, 'userChats'), 
                        where('participants', 'array-contains', user.uid),
                        where('participants', 'array-contains', request.from)
                    );
                    const existingChatSnap = await getDocs(existingChatQuery);
                    
                    let chatDocId;
                    if (existingChatSnap.empty) {
                        const newChatRef = doc(collection(db, 'userChats'));
                        chatDocId = newChatRef.id;
                        await setDoc(newChatRef, {
                            participants: [user.uid, request.from],
                            type: 'private',
                            createdAt: serverTimestamp(),
                            lastMessage: t.chatAcceptedMessage || 'Чат был принят.',
                            lastMessageTimestamp: serverTimestamp(),
                            hasUnread: { [user.uid]: false, [request.from]: true } // User accepted, sender has unread
                        });
                        await addDoc(collection(db, `userChats/${chatDocId}/messages`), {
                            senderId: user.uid,
                            senderName: user.displayName || user.email,
                            message: t.chatAcceptedMessage || 'Чат был принят.',
                            timestamp: serverTimestamp(), // Use serverTimestamp for message creation
                            isRead: false
                        });
                    } else {
                        chatDocId = existingChatSnap.docs[0].id;
                        await updateDoc(doc(db, 'userChats', chatDocId), {
                            lastMessage: t.chatAcceptedMessage || 'Чат был принят.',
                            lastMessageTimestamp: serverTimestamp(),
                            [`hasUnread.${user.uid}`]: false,
                            [`hasUnread.${request.from}`]: true,
                        });
                        await addDoc(collection(db, `userChats/${chatDocId}/messages`), {
                            senderId: user.uid,
                            senderName: user.displayName || user.email,
                            message: t.chatAcceptedMessage || 'Чат был принят.',
                            timestamp: serverTimestamp(), // Use serverTimestamp for message creation
                            isRead: false
                        });
                    }


                    setAlertInfo({ message: t.friendRequestAccepted || 'Запрос дружбы принят! Пользователь добавлен в друзья.' });
                } catch (error) {
                    console.error("Error accepting friend request:", error);
                    setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                }
            };

            const handleRejectFriendRequest = async (request) => {
                if (!user) return;
                try {
                    const friendRequestDocRef = doc(db, 'friendRequests', request.id);
                    await updateDoc(friendRequestDocRef, { status: 'rejected' });
                    // Optionally delete the request document after rejection for cleanliness
                    // await deleteDoc(friendRequestDocRef);

                    // Optionally update associated chat document if one exists for the request
                    const chatQuery = query(collection(db, 'userChats'), 
                        where('participants', 'array-contains', user.uid),
                        where('participants', 'array-contains', request.from)
                    );
                    const chatSnapshot = await getDocs(chatQuery);
                    if (!chatSnapshot.empty) {
                        const chatDocRef = doc(db, 'userChats', chatSnapshot.docs[0].id);
                        await updateDoc(chatDocRef, {
                            lastMessage: t.chatRejectedMessage || 'Запрос дружбы отклонен.',
                            lastMessageTimestamp: serverTimestamp(),
                            [`hasUnread.${user.uid}`]: false,
                            [`hasUnread.${request.from}`]: true,
                        });
                        await addDoc(collection(db, `userChats/${chatDocRef.id}/messages`), {
                            senderId: user.uid,
                            senderName: user.displayName || user.email,
                            message: t.chatRejectedMessage || 'Запрос на чат отклонен.',
                            timestamp: serverTimestamp(),
                            isRead: false
                        });
                    }

                    setAlertInfo({ message: t.friendRequestRejected || 'Запрос дружбы отклонен.' });
                } catch (error) {
                    console.error("Error rejecting friend request:", error);
                    setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                }
            };

            const handleCancelOutgoingRequest = async (request) => {
                if (!user) return;
                setAlertInfo({
                    message: t.confirmCancelOutgoingRequest || 'Вы уверены, что хотите отменить этот исходящий запрос?',
                    onConfirm: async () => {
                        try {
                            const friendRequestDocRef = doc(db, 'friendRequests', request.id);
                            await updateDoc(friendRequestDocRef, { status: 'cancelled' });
                            // Optionally delete the request document after cancellation
                            // await deleteDoc(friendRequestDocRef);

                            // Optionally update associated chat document if one exists for the request
                            const chatQuery = query(collection(db, 'userChats'), 
                                where('participants', 'array-contains', user.uid),
                                where('participants', 'array-contains', request.to)
                            );
                            const chatSnapshot = await getDocs(chatQuery);
                            if (!chatSnapshot.empty) {
                                const chatDocRef = doc(db, 'userChats', chatSnapshot.docs[0].id);
                                await updateDoc(chatDocRef, {
                                    lastMessage: t.outgoingRequestCancelledMessage || 'Исходящий запрос отменен.',
                                    lastMessageTimestamp: serverTimestamp(),
                                    [`hasUnread.${user.uid}`]: false,
                                    [`hasUnread.${request.to}`]: true,
                                });
                                await addDoc(collection(db, `userChats/${chatDocRef.id}/messages`), {
                                    senderId: user.uid,
                                    senderName: user.displayName || user.email,
                                    message: t.outgoingRequestCancelledMessage || 'Исходящий запрос отменен.',
                                    timestamp: serverTimestamp(),
                                    isRead: false
                                });
                            }

                            setAlertInfo({ message: t.outgoingRequestCancelled || 'Исходящий запрос отменен.' });
                        } catch (error) {
                            console.error("Error cancelling outgoing chat request:", error);
                            setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                        }
                    }
                });
            };

            return (
                <div className="container mx-auto p-4 md:p-8">
                    <h1 className="text-4xl font-bold text-center mb-8 text-primary">{t.chats || 'Чаты'}</h1>
                    <div className="max-w-2xl mx-auto bg-secondary rounded-xl shadow-lg border-color p-6">
                        
                        {user && (
                            <div className="bg-tertiary p-3 rounded-lg mb-4 flex flex-col md:flex-row items-center justify-between">
                                <div className="flex items-baseline flex-grow mb-2 md:mb-0"> 
                                    <button onClick={copyUserIdToClipboard} className="bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold py-1 px-3 rounded-lg mr-2">
                                        {t.clickToCopy || 'Нажмите, чтобы скопировать'}
                                    </button>
                                    <p className="text-secondary text-sm">
                                        {t.yourId || 'Ваш уникальный ID для связи'}: 
                                        <span className="font-mono text-primary font-bold break-all ml-1">{generateShortId(user.uid)}</span> 
                                    </p>
                                </div>
                                <button onClick={() => setIsFindUserModalOpen(true)} className="bg-green-600 hover:bg-green-700 text-white font-bold p-3 rounded-full text-lg flex-shrink-0 w-12 h-12 flex items-center justify-center">
                                    +
                                </button>
                            </div>
                        )}

                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                            <div className="space-y-4">
                                <h4 className="text-lg font-semibold text-primary">{t.incomingFriendRequests || 'Входящие запросы'}</h4>
                                {loadingRequests ? <LoadingSpinner /> : (
                                    incomingRequests.length === 0 ? (
                                        <p className="text-secondary text-sm">{t.noIncomingRequests || 'Нет входящих запросов.'}</p>
                                    ) : (
                                        incomingRequests.map(request => (
                                            <div key={request.id} className="p-3 bg-tertiary rounded-lg flex flex-col md:flex-row justify-between items-center mb-2 border border-color">
                                                <div>
                                                    <p className="font-semibold text-primary">{t.requestFrom}: {request.peerName}</p>
                                                    <p className="text-sm text-secondary break-all">{generateShortId(request.from)}</p>
                                                </div>
                                                <div className="flex space-x-2 mt-2 md:mt-0">
                                                    <button onClick={() => handleAcceptFriendRequest(request)} className="bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded-lg text-sm">{t.accept || 'Принять'}</button>
                                                    <button onClick={() => handleRejectFriendRequest(request)} className="bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded-lg text-sm">{t.reject || 'Отклонить'}</button>
                                                </div>
                                            </div>
                                        ))
                                    )
                                )}
                            </div>

                            <div className="space-y-4 md:border-l md:pl-4 md:border-color"> {/* Vertical divider for md screens and above */}
                                <h4 className="text-lg font-semibold text-primary">{t.outgoingFriendRequests || 'Исходящие запросы'}</h4>
                                {loadingRequests ? <LoadingSpinner /> : (
                                    outgoingRequests.length === 0 ? (
                                        <p className="text-secondary text-sm">{t.noOutgoingRequests || 'Нет исходящих запросов.'}</p>
                                    ) : (
                                        outgoingRequests.map(request => (
                                            <div key={request.id} className="p-3 bg-tertiary rounded-lg flex flex-col md:flex-row justify-between items-center mb-2 border border-color">
                                                <div>
                                                    <p className="font-semibold text-primary">{t.requestTo}: {request.peerName}</p>
                                                    <p className="text-sm text-secondary break-all">{generateShortId(request.to)}</p>
                                                    <p className="text-sm text-secondary">{t.status}: {t.pending || 'Ожидает'}</p>
                                                </div>
                                                <div className="flex space-x-2 mt-2 md:mt-0">
                                                    <button onClick={() => handleCancelOutgoingRequest(request)} className="bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded-lg text-sm">{t.cancelRequest || 'Отменить запрос'}</button>
                                                </div>
                                            </div>
                                        ))
                                    )
                                )}
                            </div>
                        </div>

                        <div className="mb-6 space-y-4 border-t border-color pt-6">
                            <h3 className="text-xl font-bold text-primary">{t.activeChats || 'Активные чаты'}</h3>
                            {loadingChats ? <LoadingSpinner /> : (
                                (activeChats.length > 0) ? (
                                    activeChats.map(chat => (
                                        <button 
                                            key={chat.id}
                                            onClick={() => {
                                                setCurrentChatInfo({ 
                                                    id: chat.id, 
                                                    type: chat.type, 
                                                    participants: chat.participants, // Ensure participants are passed
                                                    displayPeerName: chat.displayPeerName,
                                                });
                                                setIsChatWindowOpen(true);
                                            }}
                                            className="w-full text-left p-3 bg-tertiary rounded-lg hover:bg-gray-700 transition-colors flex justify-between items-center"
                                        >
                                            <div>
                                                <p className="font-semibold text-primary">{chat.displayPeerName}</p>
                                                <p className="text-sm text-secondary truncate">{t.lastMessage || 'Последнее сообщение'}: {chat.lastMessage}</p>
                                            </div>
                                            {chat.hasUnread && ( // hasUnread is now a boolean for the current user
                                                <span className="bg-red-500 text-white text-xs font-bold px-2 py-1 rounded-full">{t.new || 'Новое'}</span>
                                            )}
                                        </button>
                                    ))
                                ) : (
                                    <p className="text-secondary">{t.noActiveChats || 'Нет активных чатов. Начните новый чат с администрацией.'}</p>
                                )
                            )}
                            {/* Option to start a new chat with admin if no active chats with admin are found */}
                            {user && activeChats.every(chat => chat.type !== 'admin') && (
                                <button onClick={() => {
                                    setCurrentChatInfo({ 
                                        id: user.uid, // Admin chat uses user's UID as doc ID
                                        type: 'admin', 
                                        displayPeerName: t.projectAdmin,
                                    });
                                    setIsChatWindowOpen(true);
                                }} className="w-full accent-bg hover:accent-bg-secondary text-white font-bold py-2 px-4 rounded-lg transition-colors mt-4">
                                    {t.startNewChat || 'Начать новый чат с администрацией'}
                                </button>
                            )}
                        </div>

                    </div>
                    {isFindUserModalOpen && (
                            <Modal onClose={() => { setIsFindUserModalOpen(false); setFoundUser(null); setSearchUserId(''); setSearchError(''); }} size="max-w-md">
                                <h3 className="text-2xl font-bold text-primary mb-4 text-center">{t.addFriend || 'Добавить друга'}</h3> {/* Changed title */}
                                <div className="flex flex-col gap-3 mb-4">
                                    <input type="text" value={searchUserId} onChange={e => setSearchUserId(e.target.value)} placeholder={t.enterUserIdToFind || 'Введите ID пользователя'} className="p-3 bg-primary rounded-lg border-color text-primary"/>
                                    <button onClick={handleFindUserById} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">{t.findUser || 'Найти'}</button>
                                </div>

                                {searchError && <p className="text-red-500 text-sm mt-2 text-center">{searchError}</p>}
                                {foundUser && (
                                    <div className="mt-4 p-3 bg-secondary rounded-lg flex flex-col md:flex-row justify-between items-center text-center md:text-left">
                                        <div className="mb-2 md:mb-0">
                                            <p className="font-semibold text-primary">{foundUser.displayName || foundUser.email}</p>
                                            <p className="text-sm text-secondary break-all">{generateShortId(foundUser.id)}</p> {/* Display short ID */}
                                        </div>
                                        <button onClick={() => handleSendFriendRequest(foundUser)} className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">
                                            {t.sendRequest || 'Отправить запрос'}
                                        </button>
                                    </div>
                                )}
                            </Modal>
                        )}
                    {isChatWindowOpen && user && currentChatInfo && (
                        <ChatWindow 
                            currentUser={user} 
                            onClose={() => setIsChatWindowOpen(false)} 
                            setAlertInfo={setAlertInfo} 
                            t={t} 
                            chatId={currentChatInfo.id} 
                            chatType={currentChatInfo.type} 
                            participantInfo={currentChatInfo}
                        />
                    )}
                </div>
            );
        }

        function AdminChatInterface({ setAlertInfo, t }) {
            const [userChats, setUserChats] = useState([]); // List of users with active chats
            const [selectedUserChat, setSelectedUserChat] = useState(null); // The chat being viewed
            const [messages, setMessages] = useState([]);
            const [newMessage, setNewMessage] = useState('');
            const [loadingChats, setLoadingChats] = useState(true);
            const [loadingMessages, setLoadingMessages] = useState(false);
            const messagesEndRef = useRef(null);

            useEffect(() => {
                // Fetch list of all chats (users who initiated contact)
                const q = query(collection(db, "chats"), orderBy('lastMessageTimestamp', 'desc'));
                const unsubscribe = onSnapshot(q, async (snapshot) => {
                    const chatsData = await Promise.all(snapshot.docs.map(async (docSnap) => {
                        const chat = { id: docSnap.id, ...docSnap.data() };
                        // Fetch user data for display name
                        const userDoc = await getDoc(doc(db, 'users', chat.userId));
                        return { 
                            ...chat, 
                            userName: userDoc.exists() ? (userDoc.data().displayName || userDoc.data().email) : chat.userEmail || chat.userId
                        };
                    }));
                    setUserChats(chatsData);
                    setLoadingChats(false);
                }, (error) => {
                    console.error("Error fetching user chats:", error);
                    setLoadingChats(false);
                    setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                });
                return () => unsubscribe();
            }, []);

            useEffect(() => {
                if (!selectedUserChat) {
                    setMessages([]);
                    return;
                }
                setLoadingMessages(true);
                const q = query(
                    collection(db, `chats/${selectedUserChat.userId}/messages`),
                    orderBy('timestamp', 'asc')
                );
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    setMessages(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
                    setLoadingMessages(false);
                    // Mark user-sent messages as read for admin
                    const unreadUserMessages = snapshot.docs.filter(doc => !doc.data().isRead && !doc.data().isAdmin);
                    unreadUserMessages.forEach(async (msgDoc) => {
                        await updateDoc(doc(db, `chats/${selectedUserChat.userId}/messages`, msgDoc.id), { isRead: true });
                    });
                    // Mark the main chat document as read for admin
                    if (selectedUserChat.hasUnreadAdmin) {
                         updateDoc(doc(db, "chats", selectedUserChat.userId), { hasUnreadAdmin: false });
                    }
                }, (error) => {
                    console.error("Error fetching chat messages for admin:", error);
                    setLoadingMessages(false);
                    setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                });
                return () => unsubscribe();
            }, [selectedUserChat]);

            useEffect(() => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            }, [messages]);

            const sendMessage = async (e) => {
                e.preventDefault();
                if (newMessage.trim() === '' || !selectedUserChat) return;

                try {
                    await addDoc(collection(db, `chats/${selectedUserChat.userId}/messages`), {
                        senderId: ADMIN_UID, // Admin UID
                        senderName: 'Admin',
                        message: newMessage,
                        timestamp: serverTimestamp(),
                        isRead: false, // User needs to read this
                        isAdmin: true
                    });
                    await updateDoc(doc(db, "chats", selectedUserChat.userId), {
                        lastMessage: newMessage,
                        lastMessageTimestamp: serverTimestamp(),
                        hasUnreadUser: true, // User has unread message from admin
                    });
                    setNewMessage('');
                } catch (error) {
                    console.error("Error sending admin message:", error);
                    setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                }
            };

            const handleFindUserById = async () => {
                const userIdToFind = prompt(t.enterUserIdToFind || 'Введите ID пользователя:');
                if (userIdToFind) {
                    const userDocRef = doc(db, 'users', userIdToFind);
                    const userDocSnap = await getDoc(userDocRef);
                    if (userDocSnap.exists()) {
                        const userData = userDocSnap.data();
                        const existingChatDoc = await getDoc(doc(db, 'chats', userIdToFind));
                        let chatToSelect;
                        if (existingChatDoc.exists()) {
                            chatToSelect = { id: existingChatDoc.id, ...existingChatDoc.data(), userId: userIdToFind, userName: userData?.displayName || userData?.email || userIdToFind };
                        } else {
                            // If no direct admin chat, create a dummy entry for selection
                            // Note: This dummy entry will not have real chat history until a message is sent.
                            chatToSelect = { id: userIdToFind, userId: userIdToFind, userEmail: userData?.email || userIdToFind, userName: userData?.displayName || userIdToFind, lastMessage: t.noChatYet || 'Нет чата', lastMessageTimestamp: new Date(), hasUnreadAdmin: false };
                        }
                        setSelectedUserChat(chatToSelect);
                    } else {
                        setAlertInfo({ message: t.userNotFound || 'Пользователь с таким ID не найден.' });
                    }
                }
            };


            return (
                <div className="p-4 md:p-8 bg-secondary rounded-xl shadow-lg border-color min-h-[500px] flex">
                    <div className="w-1/3 border-r border-color pr-4 overflow-y-auto">
                        <h3 className="text-2xl font-bold text-primary mb-4">{t.userChats}</h3>
                        <div className="mb-4">
                            <button onClick={handleFindUserById} className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                                {t.findUserById || 'Найти по ID'}
                            </button>
                        </div>
                        {loadingChats ? <LoadingSpinner /> : (
                            userChats.length === 0 ? <p className="text-secondary text-sm">{t.noChats || 'Нет активных чатов.'}</p> : (
                                userChats.map(chat => (
                                    <button
                                        key={chat.id}
                                        onClick={() => setSelectedUserChat(chat)}
                                        className={`w-full text-left p-3 rounded-lg mb-2 transition-colors ${selectedUserChat?.id === chat.id ? 'accent-bg text-white' : 'bg-tertiary text-primary hover:bg-gray-700'} flex justify-between items-center`}
                                    >
                                        <div>
                                            <p className="font-semibold">{chat.userName || chat.userEmail}</p>
                                            <p className="text-xs text-secondary opacity-80 truncate">{chat.lastMessage}</p>
                                        </div>
                                        {chat.hasUnreadAdmin && (
                                            <span className="bg-red-500 text-white text-xs font-bold px-2 py-1 rounded-full">New</span>
                                        )}
                                    </button>
                                ))
                            )
                        )}
                    </div>

                    <div className="w-2/3 pl-4 flex flex-col">
                        {selectedUserChat ? (
                            <>
                                <h3 className="text-2xl font-bold text-primary mb-4">{t.chatWith}: {selectedUserChat.userName || selectedUserChat.userEmail}</h3>
                                <div className="flex-grow overflow-y-auto pr-2 mb-4 space-y-4">
                                    {loadingMessages ? <LoadingSpinner /> : (
                                        messages.map((msg) => (
                                            <div key={msg.id} className={`flex ${msg.isAdmin ? 'justify-end' : 'justify-start'}`}>
                                                <div className={`${msg.isAdmin ? 'accent-bg text-white rounded-bl-none' : 'bg-tertiary rounded-br-none'} max-w-[75%] p-3 rounded-lg shadow`}>
                                                    <p className="font-bold text-sm mb-1">{msg.isAdmin ? 'Admin' : (msg.senderName || t.user)}</p>
                                                    <p>{msg.message}</p>
                                                    <p className="text-xs mt-1 text-right opacity-70">
                                                        {msg.timestamp?.toDate ? new Date(msg.timestamp.toDate()).toLocaleTimeString() : ''}
                                                    </p>
                                                </div>
                                            </div>
                                        ))
                                    )}
                                    <div ref={messagesEndRef} />
                                </div>
                                <form onSubmit={sendMessage} className="flex mt-auto">
                                    <input
                                        type="text"
                                        value={newMessage}
                                        onChange={(e) => setNewMessage(e.target.value)}
                                        placeholder={t.enterMessagePlaceholder}
                                        className="flex-grow p-3 bg-tertiary rounded-l-lg border-color text-primary focus:outline-none focus:ring-2 accent-border"
                                    />
                                    <button type="submit" className="accent-bg hover:accent-bg-secondary text-white font-bold py-3 px-6 rounded-r-lg transition-colors">
                                        {t.send || 'Отправить'}
                                    </button>
                                </form>
                            </>
                        ) : (
                            <p className="text-center text-secondary text-xl mt-12">{t.selectUserToChat || 'Выберите пользователя для просмотра чата.'}</p>
                        )}
                    </div>
                </div>
            );
        }


        function AdminPanel({ setPage, setAlertInfo, t, currency, convertPrice }) {
            const [activeTab, setActiveTab] = useState('products'); // 'products', 'promoCodes', 'receipts', 'chats', 'faq'

            const TabButton = ({ tabName, label }) => (
                <button
                    onClick={() => setActiveTab(tabName)}
                    className={`px-6 py-3 text-lg font-semibold rounded-t-lg transition-colors ${activeTab === tabName ? 'bg-secondary text-primary accent-border border-b-2' : 'text-secondary hover:text-primary'}`}
                >
                    {label}
                </button>
            );

            return (
                <main className="container mx-auto p-4 md:p-8">
                    <h1 className="text-4xl md:text-5xl font-black text-primary text-center mb-8 tracking-wide">{t.adminPanelTitle}</h1>
                    <div className="bg-secondary rounded-xl shadow-lg border-color p-6">
                        <div className="flex justify-center border-b border-color mb-6 overflow-x-auto pb-2">
                            <TabButton tabName="products" label={t.manageProducts} />
                            <TabButton tabName="promoCodes" label={t.managePromoCodes} />
                            <TabButton tabName="receipts" label={t.checkReceipts} />
                            <TabButton tabName="faq" label={t.manageFaq} /> {/* New FAQ Tab */}
                            <TabButton tabName="chats" label={t.chats} /> {/* New Chats Tab */}
                        </div>

                        <div>
                            {activeTab === 'products' && <AdminProductManagement {...{setAlertInfo, t, currency, convertPrice}} />}
                            {activeTab === 'promoCodes' && <AdminPromoCodeManagement {...{setAlertInfo, t}} />}
                            {activeTab === 'receipts' && <AdminReceiptCheck {...{setAlertInfo, t, currency, convertPrice}} />}
                            {activeTab === 'faq' && <AdminFaqManagement {...{setAlertInfo, t}} />} {/* Render FAQ Management */}
                            {activeTab === 'chats' && <AdminChatInterface {...{setAlertInfo, t}} />} {/* Render Admin Chat */}
                        </div>
                    </div>
                </main>
            );
        }

        function App() {
            const [user, setUser] = useState(undefined);
            const [products, setProducts] = useState([]);
            const [faqs, setFaqs] = useState([]);
            const [page, setPage] = useState('home');
            const [alertInfo, setAlertInfo] = useState(null);
            const [language, setLanguage] = useState('ru');
            const [currency, setCurrency] = useState('UZS');
            const [profileVisible, setProfileVisible] = useState(false);
            const [isPinModalVisible, setIsPinModalVisible] = useState(false);
            const [pinError, setPinError] = useState('');
            const [isAdminSessionActive, setIsAdminSessionActive] = useState(false); // New state for admin session
            const [selectedProduct, setSelectedProduct] = useState(null);
            const [purchasingProduct, setPurchasingProduct] = useState(null);
            const [yooMoneyData, setYooMoneyData] = useState(null);
            const [theme, setTheme] = useState('asonik');

            // Persist page state across refreshes
            useEffect(() => {
                const savedPage = localStorage.getItem('currentPage');
                if (savedPage) {
                    setPage(savedPage);
                }
            }, []); // Run once on mount

            useEffect(() => {
                localStorage.setItem('currentPage', page);
            }, [page]); // Save page whenever it changes


            // Check admin session on component mount
            useEffect(() => {
                const storedSession = localStorage.getItem('adminSession');
                if (storedSession) {
                    try {
                        const { expiryTime } = JSON.parse(storedSession);
                        if (Date.now() < expiryTime) {
                            setIsAdminSessionActive(true);
                        } else {
                            localStorage.removeItem('adminSession'); // Clear expired session
                        }
                    } catch (e) {
                        console.error("Error parsing admin session from localStorage:", e);
                        localStorage.removeItem('adminSession');
                    }
                }
            }, []);

            useEffect(() => { document.body.className = theme; }, [theme]);
            useEffect(() => {
                 const params = new URLSearchParams(window.location.search);
                const productId = params.get('product');
                if (productId && products.length > 0) {
                    const productToShow = products.find(p => p.id === productId);
                    if (productToShow) setSelectedProduct(productToShow);
                    window.history.replaceState({}, document.title, window.location.pathname);
                }
            }, [products]);
            
            const isAdmin = user && user.uid === ADMIN_UID;
            const t = translations[language] || translations.ru;
            
            useEffect(() => {
                const unsubscribe = onAuthStateChanged(auth, (currentUser) => {
                    setUser(currentUser);
                     // Add user to 'users' collection if they don't exist
                    if (currentUser) {
                        const userDocRef = doc(db, 'users', currentUser.uid);
                        getDoc(userDocRef).then(docSnap => {
                            if (!docSnap.exists()) {
                                setDoc(userDocRef, {
                                    uid: currentUser.uid,
                                    displayName: currentUser.displayName || currentUser.email.split('@')[0], // Use email prefix if no display name
                                    email: currentUser.email,
                                    photoURL: currentUser.photoURL || '',
                                    createdAt: serverTimestamp(),
                                    lastLogin: serverTimestamp(),
                                    friends: [], // Initialize friends array
                                    friendRequests: [] // Initialize friendRequests array
                                }, { merge: true });
                            } else {
                                // Update existing user's display name and photoURL from auth if they change it in profile modal
                                const updateData = { lastLogin: serverTimestamp() };
                                if (docSnap.data().displayName !== currentUser.displayName) {
                                    updateData.displayName = currentUser.displayName || currentUser.email.split('@')[0];
                                }
                                if (docSnap.data().photoURL !== currentUser.photoURL) {
                                    updateData.photoURL = currentUser.photoURL || '';
                                }
                                // Ensure friends and friendRequests are initialized if not present
                                if (!docSnap.data().friends) updateData.friends = [];
                                if (!docSnap.data().friendRequests) updateData.friendRequests = [];

                                updateDoc(userDocRef, updateData);
                            }
                        }).catch(error => console.error("Error setting user doc:", error));
                    }
                });
                return () => unsubscribe();
            }, []);

            useEffect(() => {
                const q = query(collection(db, "products"), orderBy('createdAt', 'desc'));
                const unsubProducts = onSnapshot(q, (snapshot) => setProducts(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))));
                const unsubFaqs = onSnapshot(collection(db, "faq"), (snapshot) => setFaqs(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))));
                return () => { unsubProducts(); unsubFaqs(); };
            }, []);

            const handleLogin = async () => { try { await signInWithPopup(auth, provider); } catch (error) { setAlertInfo({ message: "Login failed: " + error.message }); } };
            const handleLogout = async () => { 
                try { 
                    await signOut(auth); 
                    localStorage.removeItem('adminSession'); // Clear session on logout
                    setIsAdminSessionActive(false);
                    setPage('home'); 
                } catch (error) { 
                    console.error("Logout Error:", error); 
                } 
            };
            
            const handleAdminClick = () => {
                if (isAdmin && isAdminSessionActive) {
                    setPage('admin'); // Bypass PIN if session is active
                } else {
                    setIsPinModalVisible(true);
                }
            };

            const handlePinSubmit = (pin, rememberMe) => {
                if (pin === ADMIN_PIN) {
                    if (rememberMe) {
                        const expiryTime = Date.now() + 15 * 60 * 1000; // Changed to 15 minutes
                        localStorage.setItem('adminSession', JSON.stringify({ expiryTime }));
                        setIsAdminSessionActive(true);
                    }
                    setPage('admin');
                    setIsPinModalVisible(false);
                    setPinError('');
                    return true;
                } else {
                    setPinError('Неверный ПИН-код');
                    return false;
                }
            };

            const handleBuy = (product) => {
                if (user) {
                    setSelectedProduct(null);
                    setPurchasingProduct(product);
                } else {
                    setAlertInfo({ message: t.loginToBuy });
                }
            };

            const handleYooMoneyPayment = (product, purchaseDetails) => {
                setYooMoneyData({ product, purchaseDetails });
            };

            const handleReceiptSubmit = async (product, purchaseDetails, receiptData) => {
                if (!user) return;
                const { receiptFile, contactTelegram, contactEmail } = receiptData;
                const formData = new FormData();
                formData.append('image', receiptFile);

                try {
                    const imgbbResponse = await fetch(`https://api.imgbb.com/1/upload?key=${IMGBB_API_KEY}`, { method: 'POST', body: formData });
                    const imgbbResult = await imgbbResponse.json();
                    if (!imgbbResult.success) throw new Error(imgbbResult.error.message || 'ImgBB upload failed');
                    
                    const purchaseCode = generatePurchaseCode();
                    
                    // Construct purchasePayload based on whether a variant was selected
                    const purchasePayload = {
                        userId: user.uid, userEmail: user.email,
                        productId: product.id, productName: product.name,
                        timestamp: serverTimestamp(),
                        originalPrice: product.selectedVariant ? product.selectedVariant.price : product.price, // Use selected variant price
                        finalPrice: purchaseDetails.finalPrice,
                        promoCodeUsed: purchaseDetails.promoCodeUsed,
                        paymentMethod: purchaseDetails.paymentMethod,
                        contactTelegram, contactEmail, 
                        receiptImageUrl: imgbbResult.data.url,
                        status: 'pending',
                        purchaseCode: purchaseCode,
                        nominal: product.selectedVariant ? product.selectedVariant.nominal : product.nominal, // Pass selected nominal
                    };
                    await addDoc(collection(db, 'purchases'), purchasePayload);

                    if (purchaseDetails.promoCodeUsed) {
                        const promoRef = doc(db, 'promoCodes', purchaseDetails.promoCodeUsed);
                        await updateDoc(promoRef, { timesUsed: increment(1) });
                    }
                    
                    // Decrement stock quantity for the selected variant
                    if (product.variants && product.selectedVariantIndex !== undefined && product.variants[product.selectedVariantIndex]) {
                        const productDocRef = doc(db, 'products', product.id);
                        const productSnap = await getDoc(productDocRef); // Get latest product data
                        if (productSnap.exists()) {
                            const currentProductData = productSnap.data();
                            const currentVariants = currentProductData.variants || [];
                            const updatedVariants = currentVariants.map((v, idx) => 
                                idx === product.selectedVariantIndex ? { ...v, stockQuantity: (v.stockQuantity || 0) - 1 } : v
                            );
                             await updateDoc(productDocRef, { variants: updatedVariants });
                        }
                    } else if (product.stockQuantity !== undefined) { // Fallback for old single-stock products
                        await updateDoc(doc(db, 'products', product.id), { stockQuantity: increment(-1) });
                    }

                    const productRef = doc(db, 'products', product.id);
                    await updateDoc(productRef, { popularity: increment(1) });

                    setAlertInfo({ message: `${t.receiptSent}\n\n${t.yourPurchaseCode}: ${purchaseCode}` });

                } catch (error) {
                    console.error("Receipt submission error:", error);
                    setAlertInfo({ message: `${t.errorOccurred}: ${error.message}` });
                    throw error;
                }
            };

            const handleConfirmPurchase = async (product, purchaseDetails, initialChatMessage = '') => { // Added initialChatMessage
                if (!user) return;
                try {
                    const purchaseCode = generatePurchaseCode();

                    // Construct purchasePayload based on whether a variant was selected
                    const purchasePayload = {
                        userId: user.uid, userEmail: user.email,
                        productId: product.id, productName: product.name,
                        timestamp: serverTimestamp(),
                        originalPrice: product.selectedVariant ? product.selectedVariant.price : product.price, // Use selected variant price
                        finalPrice: purchaseDetails.finalPrice,
                        promoCodeUsed: purchaseDetails.promoCodeUsed,
                        paymentMethod: purchaseDetails.paymentMethod,
                        status: 'contacted',
                        purchaseCode: purchaseCode,
                        nominal: product.selectedVariant ? product.selectedVariant.nominal : product.nominal, // Pass selected nominal
                    };
                    await addDoc(collection(db, 'purchases'), purchasePayload);
                    
                    if (purchaseDetails.promoCodeUsed) {
                        const promoRef = doc(db, 'promoCodes', purchaseDetails.promoCodeUsed);
                        await updateDoc(promoRef, { timesUsed: increment(1) });
                    }
                    
                    // Decrement stock quantity for the selected variant
                    if (product.variants && product.selectedVariantIndex !== undefined && product.variants[product.selectedVariantIndex]) {
                         const productDocRef = doc(db, 'products', product.id);
                        const productSnap = await getDoc(productDocRef); // Get latest product data
                        if (productSnap.exists()) {
                            const currentProductData = productSnap.data();
                            const currentVariants = currentProductData.variants || [];
                            const updatedVariants = currentVariants.map((v, idx) => 
                                idx === product.selectedVariantIndex ? { ...v, stockQuantity: (v.stockQuantity || 0) - 1 } : v
                            );
                             await updateDoc(productDocRef, { variants: updatedVariants });
                        }
                    } else if (product.stockQuantity !== undefined) { // Fallback for old single-stock products
                        await updateDoc(doc(db, 'products', product.id), { stockQuantity: increment(-1) });
                    }

                    const productRef = doc(db, 'products', product.id);
                    await updateDoc(productRef, { popularity: increment(1) });

                    // Send initial message to chat if provided (from "contact seller" button)
                    if (initialChatMessage) {
                         await addDoc(collection(db, `chats/${user.uid}/messages`), {
                            senderId: user.uid,
                            senderName: user.displayName || user.email,
                            message: initialChatMessage,
                            timestamp: serverTimestamp(),
                            isRead: false,
                            isAdmin: false
                        });
                        // Also update the main chat document for admin to see latest message and user info
                        await setDoc(doc(db, "chats", user.uid), {
                            lastMessage: initialChatMessage,
                            lastMessageTimestamp: serverTimestamp(),
                            userId: user.uid,
                            userName: user.displayName || user.email,
                            userEmail: user.email,
                            hasUnreadAdmin: true, 
                            hasUnreadUser: false, 
                        }, { merge: true });
                    }
                    
                    setAlertInfo({ message: `${t.contactSellerToReceive}\n\n${t.yourPurchaseCode}: ${purchaseCode}` });

                } catch (error) { 
                    console.error("Purchase creation error: ", error);
                    setAlertInfo({ message: t.errorOccurred });
                }
            };

            const handleDeleteProduct = (productId) => {
                setAlertInfo({
                    message: t.confirmDelete,
                    onConfirm: async () => {
                        try {
                            await deleteDoc(doc(db, "products", productId));
                            setAlertInfo({ message: t.productDeleted });
                        } catch (error) {
                            setAlertInfo({ message: t.errorOccurred });
                        }
                    }
                });
            };
            
            const handleAlertConfirm = () => { if (alertInfo && alertInfo.onConfirm) alertInfo.onConfirm(); setAlertInfo(null); };

            const renderContent = () => {
                switch (page) {
                    case 'admin': return isAdmin ? <AdminPanel {...{setPage, setAlertInfo, t, currency, convertPrice}} /> : <HomePage {...{products, onProductClick: setSelectedProduct, t, currency, convertPrice, loading: products.length === 0}} />;
                    case 'purchases': return user ? <MyPurchasesPage {...{user, t, currency, convertPrice, setAlertInfo}} /> : <div className="text-center text-primary p-10">{t.loginToView}</div>;
                    case 'faq': return <FAQPage faqs={faqs} t={t} />;
                    case 'chats': return user ? <ChatsPage user={user} setAlertInfo={setAlertInfo} t={t} /> : <div className="text-center text-primary p-10">{t.loginToView}</div>; // New ChatsPage
                    default: return <HomePage {...{products, onProductClick: setSelectedProduct, t, currency, convertPrice, loading: products.length === 0}} />;
                }
            };
            
            if (user === undefined) {
                return <LoadingSpinner />;
            }
            
            return (
                <div className="bg-primary min-h-screen font-sans flex flex-col">
                    <Header {...{user, onLogin: handleLogin, onLogout: handleLogout, setPage, isAdmin, t, currency, setCurrency, language, setLanguage, setProfileVisible, theme, setTheme, onAdminClick: handleAdminClick}} />
                    <div className="flex-grow">
                        {renderContent()}
                    </div>
                    
                    {selectedProduct && <ProductModal product={selectedProduct} user={user} onClose={() => setSelectedProduct(null)} onBuy={handleBuy} setAlertInfo={setAlertInfo} t={t} currency={currency} convertPrice={convertPrice} />}
                    {purchasingProduct && user && <PurchaseModal product={purchasingProduct} onClose={() => setPurchasingProduct(null)} onConfirm={handleConfirmPurchase} onYooMoney={handleYooMoneyPayment} t={t} currency={currency} convertPrice={convertPrice} setAlertInfo={setAlertInfo} />}
                    {yooMoneyData && user && <YooMoneyModal data={yooMoneyData} onClose={() => setYooMoneyData(null)} onSubmitReceipt={handleReceiptSubmit} t={t} currency={currency} convertPrice={convertPrice} setAlertInfo={setAlertInfo} />}
                    {alertInfo && <AlertModal message={alertInfo.message} onConfirm={alertInfo.onConfirm ? handleAlertConfirm : null} onCancel={() => setAlertInfo(null)} t={t} />}
                    {profileVisible && user && <ProfileModal user={user} onClose={() => setProfileVisible(false)} t={t} setAlertInfo={setAlertInfo} onLogout={handleLogout} />} {/* Pass onLogout */}
                    {isPinModalVisible && <PinModal onSubmit={handlePinSubmit} error={pinError} onClose={() => setIsPinModalVisible(false)} t={t} />}
                    <Footer t={t}/>
                </div>
            );
        }
        
        const translations = {
            ru: {
                home: 'Главная', support: 'Поддержка', faq: 'FAQ', adminPanelTitle: 'Админ-панель', profile: 'Профиль', logout: 'Выйти', login: 'Войти',
                buy: 'Купить', confirmation: 'Подтверждение', cancel: 'Отмена', ok: 'OK', confirm: 'Подтвердить',
                loginToView: 'Пожалуйста, войдите, чтобы просмотреть.',
                loginToBuy: 'Пожалуйста, войдите, чтобы совершить покупку.',
                imageNotFound: 'Изображение не найдено',
                catalogTitle: 'КАТАЛОГ ТОВАРОВ', catalogSubtitle: 'Лучшие предложения только для вас',
                addProduct: 'Добавить товар', editProduct: 'Редактировать товар', edit: 'Ред.', delete: 'Удал.',
                productName: 'Название товара', productNominal: 'Номинал (н-р: 100 гемов)', description: 'Описание', priceInRub: 'Цена (в RUB)', imageUrl: 'URL изображения', productImages: 'URL изображений товара', addImage: 'Добавить фото',
                addProductBtn: 'Добавить товар', updateProduct: 'Обновить товар', fillAllFields: 'Пожалуйста, заполните все поля.', productList: 'Список товаров',
                productAdded: 'Товар успешно добавлен!', productUpdated: 'Товар успешно обновлен!', errorOccurred: 'Произошла ошибка.',
                confirmDelete: 'Вы уверены, что хотите удалить этот товар?', productDeleted: 'Товар удален.',
                supportTickets: 'Тикеты поддержки', user: 'Пользователь',
                noTickets: 'У вас пока нет обращений.',
                loginForSupport: 'Пожалуйста, войдите в аккаунт, чтобы написать в поддержку.',
                avatarUpdated: 'Аватар успешно обновлен!', uploadingAvatar: 'Загрузка аватара', revertAvatar: 'Вернуть исходный аватар', avatarReverted: 'Аватар возвращен.',
                enterMessagePlaceholder: 'Введите ваше сообщение...',
                checkout: 'Оформление заказа', youAreBuying: 'Вы покупаете', choosePayment: 'Выберите способ оплаты',
                contactSeller: 'Связаться с продавцом', // Updated
                rightsReserved: 'Все права защищены.', developedWithLove: 'Дизайн и разработка с ❤️',
                russian: 'Русский', english: 'English', uzbek: 'O\'zbekcha',
                ruble: 'Рубль', dollar: 'Доллар', sum: "So'm",
                all: 'Все', today: 'За сегодня', last3days: 'За 3 дня', product: 'Товар', date: 'Дата',
                searchPlaceholder: 'Поиск по названию...', category: 'Категория', games: 'Игры', apps: 'Приложения', sortBy: 'Сортировка', newSort: 'Новые', popularSort: 'Популярные', productsNotFound: 'Товары не найдены',
                pinProduct: 'Закрепить товар', pinned: 'Закреплено', loading: 'Загрузка...',
                noApiKey: 'Ключ API для ImgBB не установлен!',
                linkCopied: 'Ссылка скопирована!',
                manageProducts: 'Управление товарами', backToPanel: 'Назад в панель', uploadAvatar: 'Загрузить аватар',
                chatWithAdmin: 'Чат с администрацией', chatWith: 'Чат с', supportSubtitle: 'Если у вас есть вопросы, нажмите кнопку ниже, чтобы начать чат.',
                darkTheme: 'Темная', lightTheme: 'Светлая', asonikTheme: 'Фирменная', setColorAvatar: 'Установить цвет рамки', // Updated
                manageFaq: 'Управление FAQ', faqTitle: 'Часто задаваемые вопросы',
                managePromoCodes: 'Промокоды', promoCode: 'Промокод', discount: 'Скидка', addPromoCode: 'Добавить промокод',
                promoCodeName: 'Название промокода', discountPercentage: 'Размер скидки', existingPromoCodes: 'Существующие промокоды',
                promoAdded: 'Промокод добавлен!', promoDeleted: 'Промокод удален!', confirmDeletePromo: 'Вы уверены, что хотите удалить этот промокод?',
                payWithPromo: 'Применить промокод', apply: 'Применить', promoNotFound: 'Промокод не найден или недействителен.', promoApplied: 'Промокод применен',
                usageLimit: 'Лимит использований', used: 'Использовано', promoLimitReached: 'Лимит использования этого промокода исчерпан.',
                verifiedByStore: 'Подтверждено магазином',
                yooMoneyPayment: 'Оплата через YooMoney', yooMoneyInstruction: 'Отсканируйте QR-код или перейдите по ссылке ниже для оплаты.',
                amountToPay: 'Сумма к оплате:', orPayWithLink: 'Или оплатите по ссылке:',
                afterPaymentTitle: 'Подтверждение оплаты',
                telegramUsername: 'Ваш Telegram аккаунт',
                contactEmail: 'Ваша контактная почта',
                uploadReceipt: 'Загрузите скриншот чека',
                sendForVerification: 'Отправить на проверку',
                sending: 'Отправка...',
                receiptSent: "Ваша заявка отправлена на проверку! Обязательно сохраните код покупки.",
                checkReceipts: 'Проверка покупок',
                noPendingReceipts: 'Нет покупок, ожидающих проверки.',
                approve: 'Одобрить',
                reject: 'Отклонить',
                amount: 'Сумма',
                adminComment: 'Комментарий администратора',
                myPurchases: 'Мои покупки',
                noPurchasesYet: 'У вас еще нет покупок.',
                statusPending: 'На проверке',
                statusApproved: 'Одобрена',
                statusRejected: 'Отклонена',
                statusContacted: 'Ожидает связи',
                statusCancelled: 'Отменен',
                contactSellerToReceive: 'Связаться с продавцом',
                cancelOrder: 'Отменить заказ',
                confirmCancelPurchase: 'Вы уверены, что хотите отменить этот заказ?',
                purchaseCancelled: 'Заказ отменен.',
                chats: 'Чаты', // New menu item
                yourId: 'Ваш уникальный ID для связи',
                userChats: 'Чаты с пользователями',
                filterByDate: 'Фильтр',
                priceAsc: 'По цене',
                adminAccess: 'Доступ для администратора',
                enterPin: 'Введите ПИН-код',
                enter: 'Войти',
                adminChatsInPanel: 'Ваши чаты находятся в админ-панели.',
                yourPurchaseCode: 'Ваш уникальный код покупки',
                idCopied: 'ID скопирован в буфер обмена!',
                clickToCopy: 'Нажмите, чтобы скопировать',
                other: 'Другое', // Added for categories
                noPromoCodes: 'Промокоды не найдены.',
                editPromoCode: 'Редактировать промокод',
                updatePromo: 'Обновить промокод',
                addFaq: 'Добавить FAQ', // New translations for FAQ
                editFaq: 'Редактировать FAQ',
                updateFaq: 'Обновить FAQ',
                noFaqs: 'FAQ не найдены.',
                confirmDeleteFaq: 'Вы уверены, что хотите удалить этот FAQ?',
                faqAdded: 'FAQ добавлен!',
                faqUpdated: 'FAQ обновлен!',
                faqDeleted: 'FAQ удален.',
                question: 'Вопрос',
                answer: 'Ответ',
                viewReceipt: 'Посмотреть чек',
                receiptDetails: 'Детали чека',
                adminCommentPlaceholder: 'Оставьте комментарий (необязательно)',
                purchaseApproved: 'Покупка одобрена!',
                purchaseRejected: 'Покупка отклонена.',
                noChatMessages: 'Сообщений пока нет. Начните чат!',
                send: 'Отправить',
                you: 'Вы',
                noChats: 'Нет активных чатов.',
                selectUserToChat: 'Выберите пользователя для просмотра чата.',
                clearAllFaqs: 'Очистить все FAQ', // New translation
                allFaqsCleared: 'Все FAQ успешно удалены.', // New translation
                rememberMe: 'Запомнить меня (15 минут)', // New translation (updated to 15 minutes)
                cloneProduct: 'Клонировать товар', // New translation for product cloning
                productCloned: 'Товар успешно клонирован!', // New translation for product cloning
                copyText: 'Копия', // Used for naming cloned products
                errorUploadingImage: 'Ошибка загрузки изображения', // New translation for image upload error
                removeFromSale: 'Снять с продажи', // New translation
                putOnSale: 'Вернуть в продажу', // New translation
                removedFromSale: 'Снято с продажи', // New translation
                putOnSaleSuccess: 'Товар выставлен на продажу.', // New translation
                removeFromSaleSuccess: 'Товар снят с продажи.', // New translation
                enterStockQuantity: 'Введите количество товара в наличии:', // New translation
                invalidQuantity: 'Неверное количество. Товар не будет выставлен на продажу.', // New translation
                outOfStock: 'Нет в наличии', // New translation
                outOfStockMessage: 'Этот товар временно отсутствует на складе.', // New translation
                stockQuantity: 'Наличие', // New translation
                productVariants: 'Варианты товара', // New translation
                nominalExample: '500 гемов', // New translation
                price: 'Цена', // New translation (already existed, but ensuring context)
                remove: 'Удалить', // New translation
                addVariant: 'Добавить вариант', // New translation
                priceFrom: 'Цена от', // New translation
                chooseOption: 'Выберите вариант:', // New translation
                moreOptions: 'варианта', // New translation
                enterStockQuantityForVariant: 'Введите количество товара в наличии для варианта', // New translation
                autoChatMessagePrefix: 'Я хочу купить товар:', // New translation for auto chat message
                forPrice: 'за', // New translation for auto chat message
                thankYouForRequest: 'Спасибо за запрос! Он будет обработан в течение 24 часов.', // New translation
                firstName: 'Имя', // New translation for profile
                lastName: 'Фамилия', // New translation for profile
                nickname: 'Никнейм', // New translation for profile
                updateProfile: 'Обновить профиль', // New translation for profile
                defaultNominal: 'Базовый', // Added for default variant
                projectAdmin: 'Администрация проекта', // New translation for chat list
                activeChats: 'Активные чаты', // New translation for chat list
                lastMessage: 'Последнее сообщение', // New translation for chat list
                new: 'Новое', // New translation for chat list
                noActiveChats: 'Нет активных чатов. Начните новый чат с администрацией.', // New translation for chat list
                startNewChat: 'Начать новый чат с администрацией', // New translation for chat list
                findUser: 'Найти пользователя', // New translation for chat search
                findUserToChat: 'Найти пользователя для чата', // New translation for chat search section title
                sendRequest: 'Отправить запрос', // Changed from sendChatRequest
                enterUserIdToFind: 'Введите ID пользователя для поиска.', // New translation for chat search prompt
                userNotFound: 'Пользователь с таким ID не найден.', // New translation for chat search
                cannotAddSelf: 'Вы не можете добавить себя в друзья.', // New translation
                alreadyFriends: 'Этот пользователь уже у вас в друзьях.', // New translation
                pendingRequestExists: 'Запрос дружбы с этим пользователем уже отправлен или находится на рассмотрении.', // New translation
                friendRequestSent: 'Запрос дружбы отправлен пользователю', // New translation
                chatRequestMessage: 'Я хочу начать с Вами чат. Пожалуйста, примите мой запрос.', // New translation for initial chat message (used for chat creation on accept)
                incomingFriendRequests: 'Входящие запросы', // Changed from incomingChatRequests
                noIncomingRequests: 'Нет входящих запросов.', // New translation
                requestFrom: 'Запрос от', // New translation
                accept: 'Принять', // New translation
                outgoingFriendRequests: 'Исходящие запросы', // Changed from outgoingChatRequests
                noOutgoingRequests: 'Нет исходящих запросов.', // New translation
                requestTo: 'Запрос к', // New translation
                pending: 'Ожидает', // New translation
                chatAcceptedMessage: 'Чат был принят.', // New translation
                chatRejectedMessage: 'Запрос на чат отклонен.', // New translation
                friendRequestAccepted: 'Запрос дружбы принят! Пользователь добавлен в друзья.', // New translation
                friendRequestRejected: 'Запрос дружбы отклонен.', // New translation
                chatWithUser: 'Чат с пользователем', // New translation
                unknownUser: 'Неизвестный пользователь', // New translation
                groupChat: 'Групповой чат', // New translation
                chatRequestSentInitialMessage: 'Запрос на чат отправлен.', // New translation (more specific)
                hasIncomingRequest: 'У вас уже есть входящий запрос от этого пользователя. Пожалуйста, примите его.', // New translation (might not be needed with friend system)
                chatRequests: 'Запросы на чат', // New combined title for requests (might not be needed with friend system)
                cancelRequest: 'Отменить запрос', // New translation for cancelling outgoing requests
                confirmCancelOutgoingRequest: 'Вы уверены, что хотите отменить этот исходящий запрос?', // New translation for confirmation
                outgoingRequestCancelled: 'Исходящий запрос отменен.', // New translation for success message
                outgoingRequestCancelledMessage: 'Исходящий запрос отменен.', // New translation for last message in chat
                setColorBorder: 'Установить цвет рамки', // New translation for profile color
                noChatYet: 'Нет активного чата.', // New translation for admin interface
            },
            en: {
                home: 'Home', support: 'Support', faq: 'FAQ', adminPanelTitle: 'Admin Panel', profile: 'Profile', logout: 'Logout', login: 'Login',
                buy: 'Buy', confirmation: 'Confirmation', cancel: 'Cancel', ok: 'OK', confirm: 'Confirm',
                loginToView: 'Please log in to view.',
                loginToBuy: 'Please log in to make a purchase.',
                imageNotFound: 'Image not found',
                catalogTitle: 'PRODUCT CATALOG', catalogSubtitle: 'The best offers just for you',
                addProduct: 'Add Product', editProduct: 'Edit Product', edit: 'Edit', delete: 'Delete',
                productName: 'Product Name', productNominal: 'Nominal (e.g., 100 gems)', description: 'Description', priceInRub: 'Price (in RUB)', imageUrl: 'Image URL', productImages: 'Product Image URLs', addImage: 'Add Photo',
                addProductBtn: 'Add Product', updateProduct: 'Update Product', fillAllFields: 'Please fill all fields.', productList: 'Product List',
                productAdded: 'Product added successfully!', productUpdated: 'Product updated successfully!', errorOccurred: 'An error occurred.',
                confirmDelete: 'Are you sure you want to delete this product?', productDeleted: 'Product deleted.',
                supportTickets: 'Support Tickets', user: 'User',
                noTickets: 'You have no tickets yet.',
                loginForSupport: 'Please log in to contact support.',
                avatarUpdated: 'Avatar updated successfully!', uploadingAvatar: 'Uploading avatar', revertAvatar: 'Revert to original avatar', avatarReverted: 'Avatar reverted.',
                enterMessagePlaceholder: 'Enter your message...',
                checkout: 'Checkout', youAreBuying: 'You are buying', choosePayment: 'Choose payment method',
                contactSeller: 'Contact Seller',
                rightsReserved: 'All rights reserved.', developedWithLove: 'Designed and developed with ❤️',
                russian: 'Русский', english: 'English', uzbek: 'O\'zbekcha',
                ruble: 'Ruble', dollar: 'Dollar', sum: "So'm",
                all: 'All', today: 'Today', last3days: 'Last 3 days', product: 'Product', date: 'Date',
                searchPlaceholder: 'Search by name...', category: 'Category', games: 'Games', apps: 'Apps', sortBy: 'Sort by', newSort: 'New', popularSort: 'Popular', productsNotFound: 'Products not found',
                pinProduct: 'Pin product', pinned: 'Pinned', loading: 'Loading...',
                noApiKey: 'API Key for ImgBB is not set!',
                linkCopied: 'Link copied!',
                manageProducts: 'Manage Products', backToPanel: 'Back to Panel', uploadAvatar: 'Upload Avatar',
                chatWithAdmin: 'Chat with Administration', chatWith: 'Chat with', supportSubtitle: 'If you have questions, press the button below to start a chat.',
                darkTheme: 'Dark', lightTheme: 'Light', asonikTheme: 'Asonik', setColorAvatar: 'Set Border Color',
                manageFaq: 'Manage FAQ', faqTitle: 'Frequently Asked Questions',
                managePromoCodes: 'Promo Codes', promoCode: 'Promo Code', discount: 'Discount', addPromoCode: 'Add Promo Code',
                promoCodeName: 'Promo Code Name', discountPercentage: 'Discount Percentage', existingPromoCodes: 'Existing Promo Codes',
                promoAdded: 'Promo code added!', promoDeleted: 'Promo code deleted!', confirmDeletePromo: 'Are you sure you want to delete this promo code?',
                payWithPromo: 'Apply Promo Code', apply: 'Apply', promoNotFound: 'Promo code not found or invalid.', promoApplied: 'Promo code applied',
                usageLimit: 'Usage Limit', used: 'Used', promoLimitReached: 'This promo code has reached its usage limit.',
                verifiedByStore: 'Verified by Store',
                yooMoneyPayment: 'Payment via YooMoney', yooMoneyInstruction: 'Scan the QR code or use the link below to pay.',
                amountToPay: 'Amount to pay:', orPayWithLink: 'Or pay with link:',
                afterPaymentTitle: 'Payment Confirmation',
                telegramUsername: 'Your Telegram account',
                contactEmail: 'Your contact email',
                uploadReceipt: 'Upload receipt screenshot',
                sendForVerification: 'Send for Verification',
                sending: 'Sending...',
                receiptSent: "Your request has been sent for verification! Be sure to save the purchase code.",
                checkReceipts: 'Check Purchases',
                noPendingReceipts: 'No purchases pending verification.',
                approve: 'Approve',
                reject: 'Reject',
                amount: 'Amount',
                adminComment: 'Admin Comment',
                myPurchases: 'My Purchases',
                noPurchasesYet: 'You have no purchases yet.',
                statusPending: 'Pending',
                statusApproved: 'Approved',
                statusRejected: 'Rejected',
                statusContacted: 'Awaiting Contact',
                statusCancelled: 'Cancelled',
                contactSellerToReceive: 'Order registered! Contact the seller and provide the purchase code.',
                cancelOrder: 'Cancel Order',
                confirmCancelPurchase: 'Are you sure you want to cancel this order?',
                purchaseCancelled: 'Order cancelled.',
                chats: 'Chats',
                yourId: 'Your unique ID for communication',
                userChats: 'User Chats',
                filterByDate: 'Filter',
                priceAsc: 'By Price',
                adminAccess: 'Admin Access',
                enterPin: 'Enter PIN code',
                enter: 'Enter',
                adminChatsInPanel: 'Your chats are in the admin panel.',
                yourPurchaseCode: 'Your unique purchase code',
                idCopied: 'ID copied to clipboard!',
                clickToCopy: 'Click to copy',
                clearAllFaqs: 'Clear All FAQs',
                allFaqsCleared: 'All FAQs successfully cleared.',
                rememberMe: 'Remember Me (15 minutes)',
                cloneProduct: 'Clone Product',
                productCloned: 'Product successfully cloned!',
                copyText: 'Copy',
                errorUploadingImage: 'Image upload error',
                removeFromSale: 'Remove from Sale',
                putOnSale: 'Put on Sale',
                removedFromSale: 'Removed from Sale',
                putOnSaleSuccess: 'Product put on sale.',
                removeFromSaleSuccess: 'Product removed from sale.',
                enterStockQuantity: 'Enter stock quantity:',
                invalidQuantity: 'Invalid quantity. Product will not be put on sale.',
                outOfStock: 'Out of Stock',
                outOfStockMessage: 'This product is temporarily out of stock.',
                stockQuantity: 'Stock',
                productVariants: 'Product Variants',
                nominalExample: '500 gems',
                price: 'Price',
                remove: 'Remove',
                addVariant: 'Add Variant',
                priceFrom: 'Price from',
                chooseOption: 'Choose option:',
                moreOptions: 'options',
                enterStockQuantityForVariant: 'Enter stock quantity for variant',
                autoChatMessagePrefix: 'I want to buy product:',
                forPrice: 'for',
                thankYouForRequest: 'Thank you for your request! It will be processed within 24 hours.',
                firstName: 'First Name',
                lastName: 'Last Name',
                nickname: 'Nickname',
                updateProfile: 'Update Profile',
                defaultNominal: 'Base',
            },
            uz: {
                home: 'Bosh sahifa', support: 'Qo\'llab-quvvatlash', faq: 'FAQ', adminPanelTitle: 'Admin Paneli', profile: 'Profil', logout: 'Chiqish', login: 'Kirish',
                buy: 'Sotib olish', confirmation: 'Tasdiqlash', cancel: 'Bekor qilish', ok: 'OK', confirm: 'Tasdiqlash',
                loginToView: 'Ko\'rish uchun tizimga kiring.',
                loginToBuy: 'Xarid qilish uchun tizimga kiring.',
                imageNotFound: 'Rasm topilmadi',
                catalogTitle: 'MAHSULOTLAR KATALOGI', catalogSubtitle: 'Faqat siz uchun eng yaxshi takliflar',
                addProduct: 'Mahsulot qo\'shish', editProduct: 'Mahsulotni tahrirlash', edit: 'Tahr.', delete: 'O\'chirish',
                productName: 'Mahsulot nomi', productNominal: 'Nominal (masalan: 100 gem)', description: 'Tavsif', priceInRub: 'Narx (RUBda)', imageUrl: 'Rasm URL', productImages: 'Mahsulot rasmlari URL', addImage: 'Rasm qo\'shish',
                addProductBtn: 'Mahsulot qo\'shish', updateProduct: 'Mahsulotni yangilash', fillAllFields: 'Iltimos, barcha maydonlarni to\'ldiring.', productList: 'Mahsulotlar ro\'yxati',
                productAdded: 'Mahsulot muvaffaqiyatli qo\'shildi!', productUpdated: 'Mahsulot muvaffaqiyatli yangilandi!', errorOccurred: 'Xatolik yuz berdi.',
                confirmDelete: 'Haqiqatan ҳам bu mahsulotni oʻchirib tashlamoqchimisiz?', productDeleted: 'Mahsulot oʻchirildi.',
                supportTickets: 'Qo\'llab-quvvatlash biletlari', user: 'Foydalanuvchi',
                loginForSupport: 'Yordam uchun tizimga kiring.',
                avatarUpdated: 'Avatar muvaffaqiyatli yangilandi!', uploadingAvatar: 'Avatar yuklanmoqda', revertAvatar: 'Asl avatarga qaytarish', avatarReverted: 'Avatar qaytarildi.',
                enterMessagePlaceholder: 'Xabaringizni kiriting...',
                checkout: 'Buyurtmani rasmiylashtirish', youAreBuying: 'Siz sotib olyapsiz', choosePayment: 'To\'lov usulini tanlang',
                contactSeller: 'Sotuvchi bilan bog\'lanish (Telegram)',
                rightsReserved: 'Barcha huquqlar himoyalangan.', developedWithLove: '❤️ bilan ishlab chiqilgan',
                russian: 'Русский', english: 'English', uzbek: 'O\'zbekcha',
                ruble: 'Rubl', dollar: 'Dollar', sum: "So'm",
                all: 'Barchasi', today: 'Bugun', last3days: 'Oxirgi 3 kun', product: 'Mahsulot', date: 'Sana',
                searchPlaceholder: 'Nom bo\'yicha qidirish...', category: 'Kategoriya', games: 'O\'yinlar', apps: 'Ilovalar', sortBy: 'Saralash', newSort: 'Yangilari', popularSort: 'Ommaboplari', productsNotFound: 'Mahsulotlar topilmadi',
                pinProduct: 'Mahsulotni mahkamlash', pinned: 'Mahkamlangan', loading: 'Yuklanmoqda...',
                noApiKey: 'ImgBB uchun API kaliti o\'rnatilmagan!',
                linkCopied: 'Havola nusxalandi!',
                manageProducts: 'Mahsulotlarni boshqarish', backToPanel: 'Panelga qaytish', uploadAvatar: 'Avatar yuklash',
                chatWithAdmin: 'Ma\'muriyat bilan suhbat', chatWith: 'Suhbat', supportSubtitle: 'Savollaringiz bo\'lsa, suhbatni boshlash uchun quyidagi tugmani bosing.',
                darkTheme: 'Qorong\'u', lightTheme: 'Yorug\'', asonikTheme: 'Asonik', setColorAvatar: 'Rangni o\'rnatish',
                manageFaq: 'FAQ boshqaruvi', faqTitle: 'Tez-tez so\'raladigan savollar',
                managePromoCodes: 'Promokodlar', promoCode: 'Promokod', discount: 'Chegirma', addPromoCode: 'Promokod qo\'shish',
                promoCodeName: 'Promokod nomi', discountPercentage: 'Chegirma foizi', existingPromoCodes: 'Mavjud promokodlar',
                promoAdded: 'Promokod qo\'shildi!', promoDeleted: 'Promokod o\'chirildi!', confirmDeletePromo: 'Haqiqatan ҳам bu promokodni oʻchirib tashlamoqchimisiz?',
                payWithPromo: 'Promokodni qo\'llash', apply: 'Qo\'llash', promoNotFound: 'Promokod topilmadi yoki yaroqsiz.', promoApplied: 'Promokod qo\'llanildi',
                usageLimit: 'Foydalanish chegarasi', used: 'Foydalanilgan', promoLimitReached: 'Ushbu promokodning foydalanish chegarasi tugadi.',
                verifiedByStore: 'Do\'kon tomonidan tasdiqlangan',
                yooMoneyPayment: 'Oплата через YooMoney', yooMoneyInstruction: 'Отсканируйте QR-kodni skanerlang yoki quyidagi havoladan foydalaning.',
                amountToPay: 'Summa to\'lash:', orPayWithLink: 'Yoki havola orqali to\'lang:',
                afterPaymentTitle: 'To\'lovni tasdiqlash',
                telegramUsername: 'Sizning Telegram akkauntingiz',
                contactEmail: 'Sizning aloqa emailingiz',
                uploadReceipt: 'Chek skrinshotini yuklang',
                sendForVerification: 'Tekshirishga yuborish',
                sending: 'Yuborilmoqda...',
                receiptSent: "Sizning arizangiz tekshirishga yuborildi! Xarid kodini saqlab qo\'yishni unutmang.",
                checkReceipts: 'Xaridlarni tekshirish',
                noPendingReceipts: 'Tekshirishni kutayotgan xaridlar yo\'q.',
                approve: 'Tasdiqlash',
                reject: 'Rad etish',
                amount: 'Summa',
                adminComment: 'Administrator izohi',
                myPurchases: 'Mening xaridlarim',
                noPurchasesYet: 'Sizda hali xaridlar yo\'q.',
                statusPending: 'Tekshirilmoqda',
                statusApproved: 'Tasdiqlandi',
                statusRejected: 'Rad etildi',
                statusContacted: 'Aloqani kutmoqda',
                statusCancelled: 'Bekor qilingan',
                contactSellerToReceive: 'Buyurtma ro\'yxatga olindi! Sotuvchi bilan bog\'lanish va xarid kodini taqdim eting.',
                cancelOrder: 'Buyurtmani bekor qilish',
                confirmCancelPurchase: 'Haqiqatan ҳам bu buyurtmani bekor qilmoqchimisiz?',
                purchaseCancelled: 'Buyurtma bekor qilindi.',
                chats: 'Чаты',
                yourId: 'Aloqa uchun sizning unikal ID\'ingiz',
                userChats: 'Foydalanuvchilar bilan suhbatlar',
                filterByDate: 'Filtr',
                priceAsc: 'Narx bo\'yicha',
                adminAccess: 'Admin Kirish',
                enterPin: 'PIN-kodni kiriting',
                enter: 'Kirish',
                adminChatsInPanel: 'Sizning suhbatlaringiz admin panelida.',
                yourPurchaseCode: 'Sizning unikal xarid kodingiz',
                idCopied: 'ID nusxa olindi!',
                clickToCopy: 'Nusxalash uchun bosing',
            },
        };

        const currencyRates = { RUB: 1, USD: 0.011, UZS: 140 };
        const currencySymbols = { RUB: '₽', USD: '$', UZS: "so'm" };
        const convertPrice = (priceInRub, targetCurrency) => {
            const rate = currencyRates[targetCurrency];
            const symbol = currencySymbols[targetCurrency];
            if (!rate || !priceInRub) return `0 ${symbol}`;
            const convertedPrice = priceInRub * rate;
            return `${convertedPrice.toLocaleString('ru-RU', { maximumFractionDigits: 2 })} ${symbol}`;
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
